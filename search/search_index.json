{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to The Esperanza Academy Charter School STEM Club","text":""},{"location":"#program-basics","title":"Program Basics","text":""},{"location":"#three-part-program","title":"Three Part Program","text":"<ul> <li>Basic introduction to Python programming language<ul> <li>Using trinket.io website and turtle graphics</li> </ul> </li> <li>Introduce the Raspberry Pi Pico micro controller<ul> <li>Move to MicroPython using Thonny, sensors, and optics</li> </ul> </li> <li>Build a robot car with the Cytron Maker Pi RP2040<ul> <li>MicroPython and Sensor Integration:<ul> <li>Avoid collisions</li> <li>Line following</li> <li>Remote control using a phone/tablet and LightBlue</li> </ul> </li> </ul> </li> </ul>"},{"location":"#short-course","title":"Short Course","text":"<ul> <li>Robotics combined with Python/MicroPython <ul> <li>Python Concepts</li> <li>MicroPython and Sensor Integration:<ul> <li>Avoid collisions</li> <li>Line following</li> </ul> </li> </ul> </li> </ul>"},{"location":"micropython/adc/","title":"Our Fifth Lab: Using an Analog to Digital Converter (ADC)","text":""},{"location":"micropython/adc/#parts-for-this-lab-are-in-bag-2-and-bag-5","title":"Parts for this Lab are in Bag 2 and Bag 5","text":"<ol> <li> <p>We need a single LED for this lab from bag 2.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We will also use one of the potentiometers from Bag 5.</p> <ul> <li>Insert the pins of the potentiometer into <code>j30, j28, and j26</code></li> <li>Using one of the jumper wires in Bag 5, insert one end to <code>f30</code> and the other end into the <code>j8</code> </li> <li>Take the second jumper wire, insert one end into the <code>g28</code> and the other into <code>j10</code></li> <li>Using the third jumper wire, insert one end into <code>f26</code> and the other end into <code>j6</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/adc/#what-is-analog-to-digital-conversion-adc","title":"What is Analog to Digital Conversion (ADC)?","text":"<p>The Pico has the ability to convert an analog voltage (a voltage anywhere between 0 and ADC_REF volts) to a corresponding digital (0 to 65535) reading.  We can then use that potentiometer to vary the input to one of the ADC pins by turning the knob clockwise and counter clockwise.</p> <p>Note the use of the special voltage pins (ADC_REF and AGND): The supply voltage is filtered, since we want to exclude ripples due to the chip\u2019s internal clock.</p> <p>The object of this lab is to have the external LED start out on.  Then, slowly dim the LED using the potentiometer.  Once the LED is off, slowly bring it back to full brightness.  Continue until you stop the program.</p> <ul> <li>Reading from the ADC pin is accomplished by:     <pre><code>from machine import Pin, ADC\npotentiometer = ADC(Pin(26))\ndata = potentiometer.read_u16()\n</code></pre></li> </ul> <p>Challenge</p> <p>Now that we know how to read data from the potentiometer via the built-in analog to digital converter, we want to use that data to vary the brightness of the LED.</p> <p>Remember that the brightness of the LED can be set by changing the duty cycle of the pulse width modulation, just like we did in the previous lab.</p> <ul> <li>Don't forget to comment your code!</li> </ul>"},{"location":"micropython/alternatingBlink/","title":"Our Second Lab: Using the Digital I/O Pins to Make Two LEDs Blink","text":""},{"location":"micropython/alternatingBlink/#parts-for-this-lab-are-in-bag-2","title":"Parts for this Lab are in Bag 2","text":"<ol> <li> <p>The longer lead on the LED is the Anode(+) lead.  This is the lead that you will connect to your Pico</p> <p><code>Insert the Anode leads into j20 and j19</code></p> </li> <li> <p>The shorter lead on the LED is called the Cathode(-).  This is the lead that you will connect to the ground rail.</p> <p><code>Insert the Cathode leads into the Ground(-) rail</code></p> </li> <li> <p>We will also use a resistor from one of the ground pins on the Pico and connect it to the ground rail.</p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LEDs may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/alternatingBlink/#how-would-you-make-the-leds-blink-in-an-alternating-pattern","title":"How Would You Make the LEDs Blink in an Alternating Pattern?","text":"<p>The object of this lab is to have one of the external LEDs on while the other is off.  Then switch after one second.  Continue until you stop the program.</p> <ul> <li>We can modify the first program to use two GP pins to control the external LEDs.  </li> <li>Hints: <ul> <li>Look at the Raspberry Pi Pico diagram and find the GP pins connected to <code>J20 and J19</code>.</li> <li>Start with one GP on (high) and the other off (low)</li> <li>Use the toggle function to turn each LED on and off</li> </ul> </li> </ul> <p>Challenge</p> <p>Can you add the other two LEDs in the bag and have one LED on a time?  Ideally, each LED would be on for one second while the rest were off, then the next LED would turn on, and so on.</p> <p>Think about some of the lessons you learned in the Python Class!  Here are some ideas:</p> <ul> <li> <p>Use a list to hold the GPIO pins (led1, led2, led3, led4)</p> </li> <li> <p>Use a loop to determine which LED to turn on</p> </li> <li> <p>Use a function to turn on one LED will turning the others off</p> </li> <li> <p>Don't forget to comment your code!</p> </li> </ul>"},{"location":"micropython/breadboard/","title":"Breadboards","text":"<p>We use standard solderless mini breadboards in our labs.  The breadboards have holes that are spaced 1/10th of an inch apart which is a standard for most electronics in the US.</p> <p>Our breadboards are usually 1/2 size with 400-ties.  They have a central trough and power rails on the left and right edges.</p>"},{"location":"micropython/breadboard/#breadboard-regions-and-connections","title":"Breadboard Regions and Connections","text":"<p>Learning how a breadboard works is critical for building your projects.  In the figure above you will see that there are two types of regions of the breadboard</p> <ol> <li>The side regions are called the power distribution rails.  They are similar to power lines that reach across our projects.</li> <li>The central region is call the row connector region.  In this area the horizontal rows are all connected inside the breadboard.  Within any row, columns <code>a, b, c, d and e</code> are all electrically connected.  Within any row, columns <code>f, h, i, j, and k</code> are also electrically connected.  However, there is a gap between columns e and f called the center gap or component slot that parts are usually placed over.  Components like buttons and chips usually have their pins straddle the component slot.</li> </ol>"},{"location":"micropython/breadboard/#pico-placement-on-breadboard","title":"Pico Placement on Breadboard","text":"<p>For most of our labs we place the Pico board (found in Bag 1) so that pin 1 of the Pico is in row 1 of the breadboard as in the image below.</p> <p></p> <p>This means that the GND connections to the Pico are always in rows 3, 8, 13 and 18 on both sides of the breadboard.  One of the ground pins is usually hooked up to the vertical blue power rails on the sides of the breadboard.</p>"},{"location":"micropython/breadboard/#pico-placement-annotations","title":"Pico Placement Annotations","text":"<ol> <li>GND are the ground connections.  There are 4 on each side of the board</li> <li>3.3V is the 3.3 volt power, regulated down from the 5 volts from the USB connection.</li> </ol>"},{"location":"micropython/buttonPressInterrupt/","title":"Our Third Lab Continued: Reading a Button Press (Interrupt)","text":""},{"location":"micropython/buttonPressInterrupt/#parts-for-this-lab-are-in-bag-2-and-bag-3","title":"Parts for this Lab are in Bag 2 and Bag 3","text":"<ol> <li> <p>Using the setup from the last lab, we'll use two LEDs and a resistor from Bag 2.  As a reminder:</p> <p><code>Insert the Anode (long) leads into j20 and j19</code></p> <p><code>Insert the Cathode (short) leads into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We will also use the parts from Bag 3.  As a reminder:</p> <ul> <li>The pins of the switch will straddle the channel and be inserted into <code>e28, e30, f28, and f30</code></li> <li>Using one of the jumper wires in Bag 3, insert one end to <code>j5</code> and the other end into the <code>Power(+) rail</code> </li> <li>Take the second jumper wire, insert one end into the <code>Power(+) rail</code> and the other into <code>j28</code></li> <li>Using the third jumper wire, insert one end into <code>a30</code> and the other end into <code>a20</code></li> <li>When you are finished, your breadboard should look similar to the image below (Note: your LEDs and wires may be different colors)</li> </ul> </li> </ol> <p></p>"},{"location":"micropython/buttonPressInterrupt/#what-is-an-interrupt-and-why-would-you-use-it","title":"What is an Interrupt and Why Would You Use It?","text":"<ul> <li> <p>Although the polling version is simple, it does take a lot of the processor resources. The button.value() is checked multiple times a second, even though the button might only be pressed once a day.</p> </li> <li> <p>A more efficient strategy is to use an interrupt handler.  This is a function that is \u201cregistered\u201d by MicroPython to handle external events such as button pushes.</p> </li> <li> <p>Think of it like this: instead of checking your phone every 10 seconds, waiting for a text from your friend, your phone vibrates to let you know you have a text.</p> </li> </ul>"},{"location":"micropython/buttonPressInterrupt/#how-would-you-read-the-button-using-an-interrupt","title":"How Would You Read the Button Using an Interrupt?","text":"<p>The object of this lab is still to have one of the external LEDs on while the other is off.  Then switch after each button press.  Continue until you stop the program.</p> <ul> <li>We can use the third program to continue to use two GP pins to control the external LEDs.  </li> <li>We will still use pin 15 to be an input, with the default state to be logical 0 (pulled down):<ul> <li>button = Pin(15, Pin.IN, Pin.PULL_DOWN)</li> </ul> </li> <li>This is where the program will change, an interrupt handler has two parts:<ul> <li>The function that handles the interrupt: <pre><code>def buttonPressed(pin):\n    global lastTime, led1, led2\n\n    # get the time the button was pressed and compare it with the last time\n    newTime = utime.ticks_ms()\n    if newTime - lastTime &gt; 200:\n        led1.toggle()\n        led2.toggle()\n        lastTime = newTime    \n</code></pre></li> <li>And register the function for the interrupt: <pre><code>button.irq(trigger=Pin.IRQ_FALLING, handler=buttonPressed)\n</code></pre></li> </ul> </li> <li>Finally, the program loop is just a call to the sleep function, since the interrupt handler will handle any button press</li> <li>Save your program as lab3a.py</li> <li>Don't forget to comment your code!</li> </ul>"},{"location":"micropython/buttonPressPoll/","title":"Our Third Lab: Reading a Button Press (Polling)","text":""},{"location":"micropython/buttonPressPoll/#parts-for-this-lab-are-in-bag-2-and-bag-3","title":"Parts for this Lab are in Bag 2 and Bag 3","text":"<ol> <li> <p>Using the setup from the last lab, we'll use two LEDs and a resistor from Bag 2.  As a reminder:</p> <p><code>Insert the Anode (long) leads into j20 and j19</code></p> <p><code>Insert the Cathode (short) leads into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>Take one button from Bag 3 and insert it into the bottom of the board.  The pins of the switch will straddle the channel and be inserted into <code>e28, e30, f28, and f30</code></p> </li> <li> <p>Using one of the jumper wires in Bag 3, insert one end to <code>j5</code> and the other end into the <code>Power(+) rail</code> </p> </li> <li> <p>Take the second jumper wire, insert one end into the <code>Power(+) rail</code> and the other into <code>j28</code></p> </li> <li> <p>Using the third jumper wire, insert one end into <code>a30</code> and the other end into <code>a20</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LEDs and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/buttonPressPoll/#how-would-you-read-the-button-to-make-the-leds-blink-in-an-alternating-pattern","title":"How Would You Read the Button to Make the LEDs Blink in an Alternating Pattern?","text":"<p>The object of this lab is to have one of the external LEDs on while the other is off.  Then switch after each button press.  Continue until you stop the program.</p> <ul> <li>We can use the second program to continue to use two GP pins to control the external LEDs.  </li> <li>We need to modify the program to have the Pico read from a GP pin in this lab.  To do so, designate GP pin 15 to be an input, with the default state to be logical 0 (pulled down):<ul> <li>button = Pin(15, Pin.IN, Pin.PULL_DOWN)</li> </ul> </li> <li>When the button is pressed, 3.3V (logical 1) will be applied to the input.</li> <li>The state of the button can be read at any time:<ul> <li>button.value()</li> </ul> </li> </ul>"},{"location":"micropython/buttonPressPoll/#what-does-a-button-press-look-like-to-the-pico","title":"What Does a Button Press Look Like to the Pico?","text":"<p>Hints:</p> <ul> <li> <p>You will still need the setup to control GP pins connected to the LEDs and a main loop as was done in Lab 2.</p> </li> <li> <p>You will need to define GP pin 15 as an input as shown above.  That should be done in the same section of code that defines the GP pins that control the LEDs.</p> </li> <li> <p>Check the button state inside the loop to determine if the button was pressed, using a conditional.</p> </li> <li> <p>Once the button is pressed, sleep for a moment to make sure you get a clean press and release.</p> </li> <li> <p>Save the program as lab3.py</p> </li> <li> <p>Don't forget to comment your code!</p> </li> </ul>"},{"location":"micropython/buzzer/","title":"Our Tenth Lab: Using a Buzzer with PWM","text":""},{"location":"micropython/buzzer/#parts-for-this-lab-are-in-bag-10","title":"Parts for this Lab are in Bag 10","text":"<ol> <li>Place the buzzer from Bag 10 with the positive pin (marked with a plus sign) in  <code>h30</code></li> <li>The other pin should line up into <code>f28</code></li> <li>Using one of the jumper wires in Bag 10, insert one end to <code>j30</code> and the other end into <code>j20</code></li> <li> <p>Using one of the jumper wires in Bag 10, insert one end to <code>j28</code> and the other end into <code>a18</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/buzzer/#using-a-buzzer-to-make-a-sound","title":"Using a Buzzer to Make a Sound","text":"<ul> <li> <p>We already know how to use PWM to make an LED glow brighter or dimmer.</p> </li> <li> <p>We can use the same PWM principal to make a sound with a piezo buzzer.</p> </li> </ul> <p>Challenge</p> <ul> <li>Using what you learned in the previous labs, do the following:<ul> <li>Set up GP 16 as a PWM pin</li> <li>Set the frequency to 1,000 Hz</li> <li>Set the duty cycle to 50%</li> <li>Wait 5 seconds </li> <li>Then set the duty cycle to 0 to turn off the sound</li> <li>Don't forget to comment your code!</li> </ul> </li> </ul>"},{"location":"micropython/install/","title":"Installing the Latest Version of MicroPython","text":"<p>If Thonny fails to install (or you are using another application like Visual Studio Code to work with the Pico), perform the following steps:</p> <p>Get the latest firmware release from MicroPython.org</p> <ul> <li> <p>Download the latest uf2 to your computer (Nightly builds have the latest code, but may not be stable)</p> </li> <li> <p>Hold down the boot button on the board (white button)</p> </li> <li> <p>Plug one end of the USB cable into the board and the other end into your computer</p> </li> <li> <p>The Pico should show up as a new drive (labeled RPI-RP2) available on your computer</p> </li> <li> <p>Copy the downloaded uf2 file onto the RPI-RP2 drive</p> </li> <li> <p>The Pico should reboot and be ready to use.</p> </li> <li> <p>The RPI-RP2 drive will no longer be visiable on your computer.</p> </li> </ul>"},{"location":"micropython/joystick/","title":"Our Ninth Lab: Using a Joystick to Draw Lines on an SSD1306 Digital Display","text":""},{"location":"micropython/joystick/#parts-for-this-lab-are-in-bag-8-with-the-addition-of-the-joystick","title":"Parts for this Lab are in Bag 8, with the addition of the Joystick","text":"<ol> <li> <p>Using the setup from the last lab, we'll use the display from Bag 8.  As a reminder:</p> <ul> <li>Insert the display into <code>f25, f26, f27, and f28</code></li> <li>Using one of the jumper wires in Bag 8, insert one end to <code>i25</code> and the other end into <code>i18</code></li> <li>Using another jumper wire from Bag 8, insert one end to <code>j26</code> and the other end into <code>j5</code></li> <li>Using another jumper wire from Bag 8, insert one end to <code>h27</code> and the other end into <code>b2</code></li> <li>Using another jumper wire from Bag 8, insert one end to <code>i28</code> and the other end into <code>a1</code></li> </ul> </li> <li> <p>Using the wires attached to the joystick, connect them as follows:</p> <ul> <li>The wire from GND on the joystick goes to <code>i8</code></li> <li>The wire from +5V on the joystick goes to <code>i6</code></li> <li>The wire from VRX on the joystick goes to <code>i9</code></li> <li>The wire from VRY on the joystick goes to <code>i10</code></li> <li>The wire from SW on the joystick goes to <code>j20</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/joystick/#drawing-lines-with-a-joystick-and-the-ssd1306-display","title":"Drawing Lines With a Joystick and the SSD1306 Display","text":"<ul> <li> <p>We already added the SSD1306 library to the Pico.</p> </li> <li> <p>We also took some time to look at the methods in the SSD1306 library.</p> <ul> <li>Did you notice the line method?</li> <li>The line method is called as follows:     <pre><code># Draw a line from X1, Y1 to X2, Y2 with pixels turned on\ndisplay.line(x1, y1, x2, y2, 1)\n</code></pre></li> </ul> </li> <li> <p>We learned how to read the Analog to Digital Converter inputs in Lab 5.  In this case, we are using two of the ADCs.</p> </li> <li> <p>Additionally, we learned to read a button press in Lab 3.  We do not need to use the interrupt method (although we could)</p> </li> </ul> <p>Challenge</p> <ul> <li> <p>Using what you learned in the previous labs, do the following:</p> <ul> <li>Give the user instructions on how to operate the joystick to clear the screen</li> <li>Wait for the user to press the joystick</li> <li>Clear the screen</li> <li>Read the voltages from the joystick </li> <li>Convert the voltages to a screen coordinate (X, Y)</li> <li>Draw a line from the starting position to the new position</li> <li>Continue until the user clears the screen</li> <li>Don't forget to comment your code!</li> </ul> </li> <li> <p>Hint:  You will need this formula to scale the voltage to a position <pre><code># Takes an input number value and a range between low-and-high and returns it scaled to the new range\ndef scaled(value, istart, istop, ostart, ostop):\n    return int(ostart + (ostop - ostart) * ((int(value) - istart) / (istop - istart)))\n</code></pre></p> </li> </ul>"},{"location":"micropython/neopixel/","title":"Our Seventh Lab: Using a NeoPixel Display","text":""},{"location":"micropython/neopixel/#parts-for-this-lab-are-in-bag-7","title":"Parts for this Lab are in Bag 7","text":"<ol> <li> <p>We will use the neopixel display from Bag 7.</p> <ul> <li>Insert the lead from GND of the display into <code>j3</code></li> <li>Insert the lead from VCC of the display into <code>j1</code></li> <li>Insert the lead from IN of the display into <code>a1</code></li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/neopixel/#working-with-the-neopixel-display","title":"Working With the NeoPixel Display","text":"<ul> <li> <p>NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line.</p> </li> <li> <p>Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver library so that the user's don't need to see this code.</p> </li> <li> <p>Working with the display and the library</p> <ul> <li>Import Pin and NeoPixel from their libraries     <pre><code>from machine import Pin\nfrom neopixel import NeoPixel\n</code></pre></li> <li>Define the number of pixels, the output pin, and intialize the NeoPixel class     <pre><code>NUMBER_PIXELS = 8\nLED_PIN = 0\n\npin = Pin(LED_PIN, Pin.OUT) \nstrip = NeoPixel(pin, NUMBER_PIXELS)\n</code></pre></li> <li>Finally, you can set any of the pixels either one at a time     <pre><code>for i in range(0, NUMBER_PIXELS): \n    strip [i] = (0,0,255) \n    strip.write()\n</code></pre></li> <li>Or, you can set all of the pixels at the same time     <pre><code>strip.fill(0,0,255) \nstrip.write()\n</code></pre></li> </ul> </li> </ul> <p>Challenge</p> <p>Using a variety of colors, set the pixels, one at time to each color such that it appears that the display starts out with a single pixel lit in a color, then two pixels in the same color, etc. until all 8 are lit.  Then start on a second color lighting the first pixel.</p> <p> </p> <pre><code>Colors can be found here: \n[https://www.rapidtables.com/web/color/RGB_Color.html](https://www.rapidtables.com/web/color/RGB_Color.html)\n\nOnce that works, turn the entire set of pixels on with a single color, then move to the next color that you selected.\n\n - Don't forget to comment your code!\n</code></pre>"},{"location":"micropython/onboardBlink/","title":"Our First Lab: Making the Onboard LED Blink","text":""},{"location":"micropython/onboardBlink/#connect-the-board-to-your-computer","title":"Connect the Board to Your Computer","text":"<ol> <li>Plug the small end of the USB cable to your Pico</li> <li>Plug the other end into the USB port on your Computer</li> <li>Open Thonny on your Computer</li> <li> <p>You should see the following in the Shell (Thonny's bottom window)</p> <p><code>MicroPython v1.19.1 on 2022-06-18; Raspberry Pi Pico with RP2040</code></p> <p><code>Type \"help()\" for more information.</code></p> <p><code>&gt;&gt;&gt;</code></p> </li> </ol> <p>Note: Your version of the MicroPython interpreter may be different</p>"},{"location":"micropython/onboardBlink/#typing-commands-in-the-shell","title":"Typing Commands in the Shell","text":"<p>The Shell window allows us to quickly test MicroPython commands.  Typing in the Shell window is known as typing in the REPL.  REPL stands for Read Evaluate Print Loop, and is the name given to the interactive MicroPython prompt that is accessible on the Pycom devices. </p> <p>Let's try a simple command to make sure everything is working.  Type the following at the prompt:</p> <p>print('Hello')</p> <p>The interpreter should respond with <code>Hello</code></p>"},{"location":"micropython/onboardBlink/#blinking-the-onboard-led","title":"Blinking the Onboard LED","text":"<p>Type the following in the Thonny's top window:</p> <pre><code># Load the libraries\nfrom machine import Pin \nfrom time import sleep\n\n# Define the GPIO pin that controls the LED\nled1 = Pin(25, Pin.OUT)\n\n# Turn off the LED\nled1.low()\n\n# Loop forever, while turning the LED On and Off\nwhile True:\n    led1.toggle()\n    sleep(1)\n</code></pre> <p>Once you typed in the code, be sure to save the code on your computer as lab1.py.  Then run the code by pressing the Green button.  You should see the onboard LED turn on for one second, then off for one second.</p> <p></p> <p>This program has two main parts.  The first part is often called the preamble or the setup code. This code gets executed only once when the program is run. In this example, the setup loads the right libraries and initializes global variables.</p> <p>The second part is the main event loop.  This program continues to run until the device is powered down or the program is reset.</p> <p>The <code>from machine import Pin</code> statement is required to define the characteristics of our physical machine.  In this case, we are loading the Pin python library.</p> <p>The <code>from time import sleep</code> library is required for the python sleep function.  Note that some programs use <code>utime</code> for MicroPython time.  These both work the same.  They are really just synonyms or alias of each other.  Although the use of <code>utime</code> is technically a little bit more precise - the reader knows that the code is using the actual MicroPython time library, the use of the <code>time</code> alias makes our code on character smaller and can make our code more portable to other systems.</p> <p>Note that the text after the hash or pound characters are comments.  Comments are ignored by the Python interpreter but it is a good practice to put in comments in your code to help others understand your program.</p>"},{"location":"micropython/onboardBlink/#changing-the-blink-speed","title":"Changing the Blink Speed","text":"<p>Next, lets create a Python global variable for the delay that the LED is on and off.</p> <pre><code># Load the libraries\nfrom machine import Pin \nfrom time import sleep\n\n# Define the blink delay rate\ndelay = .25\n\n# Define the GPIO pin that controls the LED\nled1 = Pin(25, Pin.OUT)\n\n# Turn off the LED\nled1.low()\n\n# Loop forever, while turning the LED On and Off\nwhile True:\n    led1.toggle()\n    sleep(delay)\n</code></pre> <p>This program will blink the built-in LED on and off every 1/4 of a second.  By changing the delay variable you can make the LED blink faster and slower.</p> <p>Challenge</p> <p>What is the fastest you can make the LED blink and still see it changing?  What does this tell you about the human eye?</p>"},{"location":"micropython/photoResistor/","title":"Our Sixth Lab: Using a Photo Resistor","text":""},{"location":"micropython/photoResistor/#parts-for-this-lab-are-in-bag-2-and-bag-6","title":"Parts for this Lab are in Bag 2 and Bag 6","text":"<ol> <li> <p>We need a single LED for this lab from bag 2.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>We will also use one of the resistors and one of the photo resistors from Bag 6.</p> <ul> <li>Insert the pins of the resistor into <code>j6 and j10</code></li> <li>Insert the pins of the photo resistor into <code>`j8 and i10</code> </li> </ul> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED and wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/photoResistor/#building-a-night-light-with-a-photo-resistor","title":"Building a Night Light With a Photo Resistor","text":"<ul> <li> <p>A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor.</p> </li> <li> <p>To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to analog ground (AGND) and reference power(ADC_REF). This will move the voltage of the midpoint of the circuit.</p> </li> <li> <p>From our previous lab, we know that the Pico has the ability to convert an analog voltage (a voltage anywhere between 0 and ADC_REF volts) to a corresponding digital (0 to 65535) reading.  We can then use that reading to determine when to turn the LED on or off</p> </li> </ul> <p>Challenge</p> <p>Use the readings from the analog to digital converter pin to determine when to turn the LED on and off.</p> <p>You may need a bright overhead light to see the change in resistance as you cover and uncover the photo resistor.</p> <ul> <li>Don't forget to comment your code!</li> </ul>"},{"location":"micropython/pico/","title":"Raspberry Pi Pico (found in Bag 1)","text":"<p>We will be working with the Raspberry Pi Pico.  It is a low-cost ($4.00), high-performance microcontroller board with flexible digital interfaces. Key features include:</p> <ul> <li> <p>RP2040 microcontroller chip designed by Raspberry Pi in the United Kingdom</p> </li> <li> <p>Dual-core Arm Cortex M0+ processor, flexible clock running up to 133 MHz</p> </li> <li> <p>264kB of SRAM, and 2MB of on-board flash memory</p> </li> <li> <p>USB 1.1 with device and host support</p> </li> <li> <p>Low-power sleep and dormant modes</p> </li> <li> <p>Drag-and-drop programming using mass storage over USB</p> </li> <li> <p>26 multi-function GPIO pins</p> </li> <li> <p>2 SPI, 2 I2C, 2 UART, 3 12-bit ADC, 16 controllable PWM channels</p> </li> <li> <p>Accurate clock and timer on-chip</p> </li> <li> <p>Temperature sensor</p> </li> <li> <p>Accelerated floating-point libraries on-chip</p> </li> <li> <p>8 Programmable I/O (PIO) state machines for custom peripheral support</p> </li> </ul>"},{"location":"micropython/pwm/","title":"Our Fourth Lab: Using Pulse Width Modulation (PWM) to Dim an LED","text":""},{"location":"micropython/pwm/#parts-for-this-lab-are-in-bag-2","title":"Parts for this Lab are in Bag 2","text":"<ol> <li> <p>We only need a single LED for this lab.  As a reminder for the setup:</p> <p><code>Insert the Anode(+) lead into j20</code></p> <p><code>Insert the Cathode(-) lead into the Ground(-) rail</code></p> <p><code>Insert the resistor leads into j3 and into the Ground(-) rail</code> </p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your LED may be a different color)</p> </li> </ol> <p></p>"},{"location":"micropython/pwm/#what-is-pulse-width-modulation-pwm","title":"What is Pulse Width Modulation (PWM)?","text":"<p>The object of this lab is to have the external LED start out on.  Then, slowly dim the LED.  Once the LED is off, slowly bring it back to full brightness.  Continue until you stop the program.</p> <p></p> <ul> <li>We used a switch in the previous labs to turn an LED on and off, but what if we wanted to dim the LED?  Since we can\u2019t control the voltage through the GP pins of our device, we have to use PWM.  PWM means that we will quickly vary the amount of time (duty cycle) that the voltage is applied to the LED.</li> </ul> <p></p>"},{"location":"micropython/pwm/#pwm-how-does-it-work","title":"PWM - How Does It Work?","text":"<ul> <li>PWM is controlled by two factors:<ul> <li>How fast does the power turn on and off (frequency)</li> <li>How long is the power on, relative to the power being off (duty cycle)</li> </ul> </li> <li>We can declare that a GP pin is a PWM pin as follows:     <pre><code>from machine import Pin, PWM\npwmPin = PWM(Pin(16))\n</code></pre></li> <li>Now set the frequency and the duty cycle:     <pre><code># Apply and remove power 1000 times/second (too fast to see)\npwmPin.freq(1000)\n\n# Apply voltage 50% of the time\n# Range is 0 - 65535\npwmPin.duty_u16(32768)\n</code></pre></li> </ul> <p>Challenge</p> <p>Now that we understand PWM, create a program that starts with the LED off, slowly brings the LED to full brightness, and then slowly back to off.</p> <p>Once that works, what happens if we repeat the exercise, starting with a frequency of 1000, and reduce the frequency to 10?  Use a list with values: 1000, 500, 100, 50, 40, 30, 20, &amp; 10. </p> <ul> <li>Don't forget to comment your code!</li> </ul>"},{"location":"micropython/ssd1306/","title":"Our Eigth Lab: Using an SSD1306 Digital Display","text":""},{"location":"micropython/ssd1306/#parts-for-this-lab-are-in-bag-8","title":"Parts for this Lab are in Bag 8","text":"<ol> <li> <p>We will use the SSD1306 display from Bag 8.</p> <ul> <li>Insert the display into <code>f25, f26, f27, and f28</code></li> </ul> </li> <li> <p>Using one of the jumper wires in Bag 8, insert one end to <code>i25</code> and the other end into <code>i18</code></p> </li> <li> <p>Using another jumper wire from Bag 8, insert one end to <code>j26</code> and the other end into <code>j5</code></p> </li> <li> <p>Using another jumper wire from Bag 8, insert one end to <code>h27</code> and the other end into <code>b2</code></p> </li> <li> <p>Using another jumper wire from Bag 8, insert one end to <code>i28</code> and the other end into <code>a1</code></p> </li> <li> <p>When you are finished, your breadboard should look similar to the image below (Note: your wires may be different colors)</p> </li> </ol> <p></p>"},{"location":"micropython/ssd1306/#working-with-the-ssd1306-display","title":"Working With the SSD1306 Display","text":"<ul> <li> <p>We'll need to add the SSD1306 Library to our Pico.  This can be done through Thonny.  Use the <code>Tools-&gt;Manage Packages...</code> menu to add the Micropython library.     </p> </li> <li> <p>Our display uses an Inter-Integrated Circuit (I2C) interface.  The I2C interface was first developed by Phillips Semiconductor in 1982 to facilitate serial communication between devices.  Our display supports 400 kbit transfer rates.  You'll see this in the I2C method definition.</p> </li> <li> <p>Working with the display and the library</p> <ul> <li>Import Pin, I2C and SSD1306_I2C from their libraries     <pre><code>from machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\n</code></pre></li> <li>Intialize the I2C and SSD1306 classes     <pre><code># Initialize the I2C interface:\n#    Use the Pico I2C 0 interface\n#    Serial Data will use GP0\n#    Serial Clock will use GP1\n#    Transfer rate will be 400,000\ni2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)\n\n# Our display is 128 pixels wide, 64 pixels high, and uses the I2C interface\ndisplay = SSD1306_I2C(128, 64, i2c)\n</code></pre></li> <li>Finally, you can use the following commands     <pre><code># Clear the display by turning all pixels off (0) or on (1)\ndisplay.fill(0)\n\n# Write some test to the framebuffer at the top left of the display\ndisplay.text(\"Hello World\", 0, 0)\n\n# Move the framebuffer to the display\ndisplay.show()\n</code></pre></li> </ul> </li> </ul> <p>Challenge</p> <ul> <li>Start by writing your name to the display at the top left corner.</li> <li>Pause for a quarter of a second</li> <li>Move your name down and to the right</li> <li>Pause again</li> <li>Continue moving down and to the right until you get tothe bottom or the right edge of the screen. </li> <li>If you hit the right edge, start moving left until you hit the left edge</li> <li>If you hit the bottom edge, start moving until you hit the top edge</li> <li> <p>Don't forget to comment your code!</p> </li> <li> <p>Explore other commands in the display library by typing in the shell:     <pre><code>from ssd1306 import SSD1306_I2C\nprint(dir(SSD1306_I2C))\n</code></pre></p> </li> </ul>"},{"location":"micropython/thonny/","title":"Thonny Python IDE","text":"<p>A lightweight Python integrated development environment (IDE) that is ideal for beginners writing simple Python programs for first time users.  It has been modified to work well with the Raspberry Pi Pico.  It supports different ways of stepping through the code, step-by-step expression evaluation, detailed visualization of the call stack and a mode for explaining the concepts of references and heap.</p> <p>Thonny 3.3.3 (2021-01-21) was the first version to support the Raspberry Pi Pico.  There have also been several enhancements since that release.  For a release history see the Thonny Release History.  We suggest checking this link monthly for updates.</p>"},{"location":"micropython/thonny/#installing-thonny","title":"Installing Thonny","text":"<p>The best way to install Thonny is to go to the Thonny web site and look for the \"Download\" for your opeating system.  That link is here:</p> <p>https://thonny.org/</p> <p>Make sure you upgrade to the latest version of Thonny if you already have Thonny installed on your computer.</p> <p>You can find more tips on getting started with Thonny on the Raspberry Pi website:</p> <p>https://projects.raspberrypi.org/en/projects/getting-started-with-the-pico/2</p>"},{"location":"micropython/thonny/#working-with-micropython-on-the-raspberry-pi-pico","title":"Working with MicroPython on the Raspberry Pi Pico","text":"<p>Once Thonny is successfully installed, make sure to change the interpreter that Thonny runs to MicroPython for the Raspberry Pi Pico.  This is done by changing the selected interpreter on the bottom right of the Thonny screen.</p> <p></p> <p>Thonny runs on Mac, Windows and Linux.</p>"},{"location":"micropython/thonny/#installing-micropython","title":"Installing MicroPython","text":"<ul> <li> <p>Hold down the boot button on the board (white button)</p> </li> <li> <p>Plug one end of the USB cable into the board and the other end into your computer</p> </li> <li> <p>The Pico should show up as a new drive (labeled RPI-RP2) available on your computer</p> </li> <li> <p>Thonny will install the latest version of MicroPython for you</p> </li> </ul> <p></p>"},{"location":"micropython/thonny/#running-help","title":"Running help()","text":"<p>You can enter the help() function in the main script area and then press the Play button.  This will tell you </p> <pre><code>MicroPython v1.14 on 2021-02-02; Raspberry Pi Pico with RP2040\nType \"help()\" for more information.\n&gt;&gt;&gt; %Run -c $EDITOR_CONTENT\nWelcome to MicroPython!\n\nFor online help please visit https://micropython.org/help/.\n\nFor access to the hardware use the 'machine' module.  RP2 specific commands\nare in the 'rp2' module.\n\nQuick overview of some objects:\n  machine.Pin(pin) -- get a pin, eg machine.Pin(0)\n  machine.Pin(pin, m, [p]) -- get a pin and configure it for IO mode m, pull mode p\n    methods: init(..), value([v]), high(), low(), irq(handler)\n  machine.ADC(pin) -- make an analog object from a pin\n    methods: read_u16()\n  machine.PWM(pin) -- make a PWM object from a pin\n    methods: deinit(), freq([f]), duty_u16([d]), duty_ns([d])\n  machine.I2C(id) -- create an I2C object (id=0,1)\n    methods: readfrom(addr, buf, stop=True), writeto(addr, buf, stop=True)\n             readfrom_mem(addr, memaddr, arg), writeto_mem(addr, memaddr, arg)\n  machine.SPI(id, baudrate=1000000) -- create an SPI object (id=0,1)\n    methods: read(nbytes, write=0x00), write(buf), write_readinto(wr_buf, rd_buf)\n  machine.Timer(freq, callback) -- create a software timer object\n    eg: machine.Timer(freq=1, callback=lambda t:print(t))\n\nPins are numbered 0-29, and 26-29 have ADC capabilities\nPin IO modes are: Pin.IN, Pin.OUT, Pin.ALT\nPin pull modes are: Pin.PULL_UP, Pin.PULL_DOWN\n\nUseful control commands:\n  CTRL-C -- interrupt a running program\n  CTRL-D -- on a blank line, do a soft reset of the board\n  CTRL-E -- on a blank line, enter paste mode\n\nFor further help on a specific object, type help(obj)\nFor a list of available modules, type help('modules')\n&gt;&gt;&gt; \n</code></pre>"},{"location":"micropython/thonny/#save-options","title":"Save Options","text":"<p>You can save a python file in Thonny to either the Pico or to your local computer's file system.</p> <p></p> <p>first stop execution of any program you are running.</p>"},{"location":"micropython/thonny/#version","title":"Version","text":"<p>After you press play the following will appear in the console.</p> <pre><code>MicroPython v1.13-290-g556ae7914 on 2021-01-21; Raspberry Pi Pico with RP2040\nType \"help()\" for more information.\n&gt;&gt;&gt; %Run -c $EDITOR_CONTENT\n</code></pre>"},{"location":"micropython/thonny/#background-on-thonny","title":"Background on Thonny","text":"<p>MicroPython was originally developed by Damien George and first released in 2014.  However, MicroPython did not have a development environment that was easy for students to use.  Thonny was developed to provide an easy to use tool just for MicroPython development.  Thonney was created at the University of Tartu Institute of Computer Science in Estonia for this purpose.  They continue to support Thonny.</p> <p>Several feature for Thonny were sponsored by the Raspberry Pi Foundation and we continue to see a close relationship between the Raspberry Pi Foundation and the Thonny development team.</p> <ul> <li>Thonny web site</li> </ul>"},{"location":"micropython/solutions/lab10/","title":"Our Tenth Lab: Using a Buzzer with PWM","text":""},{"location":"micropython/solutions/lab10/#solution-using-a-buzzer-to-make-a-sound","title":"Solution: Using a Buzzer to Make a Sound","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 02/03/2022\n# Creating a tone\nfrom machine import Pin, PWM\nfrom utime import sleep\n\n# lower right corner with USB connector on top\nSPEAKER_PIN = 16\n\n# create a Pulse Width Modulation Object on this pin\nspeaker = PWM(Pin(SPEAKER_PIN))\n\n# set the duty cycle to be 50%\nspeaker.duty_u16(1000)\n\n# Set the frequency\nspeaker.freq(1000)\n\nsleep(5) # wait 5 seconds\n\n# turn off the PWM circuit off with a zero duty cycle\nspeaker.duty_u16(0)\n</code></pre>"},{"location":"micropython/solutions/lab2/","title":"Our Second Lab: Using the Digital I/O Pins to Make Two LEDs Blink","text":""},{"location":"micropython/solutions/lab2/#solution-blinking-two-leds","title":"Solution: Blinking Two LEDs","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/13/2022\n# Alternating blinking leds\nfrom machine import Pin\nfrom time import sleep\n\n# Define the pin for each led\nled1 = Pin(16, Pin.OUT)\nled2 = Pin(17, Pin.OUT)\n\n\n# make sure one is off and one is on\nled1.low()\nled2.high()\n\n\n# Toggle on for 1 second, then off for one second forever\nwhile True:\n    led1.toggle()\n    led2.toggle()\n    sleep(1)\n</code></pre>"},{"location":"micropython/solutions/lab2/#solution-challenge-blinking-four-leds","title":"Solution: Challenge - Blinking Four LEDs","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 12/26/2022\n# Alternating blinking leds\nfrom machine import Pin\nfrom time import sleep\n\n# Define the pin for each led\nled1 = Pin(16, Pin.OUT)\nled2 = Pin(17, Pin.OUT)\nled3 = Pin(18, Pin.OUT)\nled4 = Pin(19, Pin.OUT)\n\n# Create a list of LEDs\nleds = [led1, led2, led3, led4]\n\n# define a function to turn on one LED and turn the others off\ndef toggleLeds(led, leds):\n\n    # Turn one LED on\n    led.high()\n\n    # Loop through all of the LEDs\n    for offLed in leds:\n\n        # Is this the LED that is on?  If not, turn the LED off.\n        if led != offLed:\n            offLed.low()\n\n# Toggle a LED on for 1 second forever\nwhile True:\n    for led in leds:\n        toggleLeds(led, leds)\n        sleep(1)\n</code></pre>"},{"location":"micropython/solutions/lab3i/","title":"Our Third Lab: Reading a Button Press","text":""},{"location":"micropython/solutions/lab3i/#solution-interrupt-method","title":"Solution: Interrupt Method","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/13/2022\n# Alternating blinking leds\nfrom machine import Pin\nimport utime\nfrom time import sleep\n\n# define the last time a button was pressed\nlastTime = 0\n\n# Define the pin for each led\nled1 = Pin(16, Pin.OUT)\nled2 = Pin(17, Pin.OUT)\n\n# define the pin for the button\nbutton = Pin(15, Pin.IN, Pin.PULL_DOWN)\n\n# make sure one is off and one is on\nled1.low()\nled2.high()\n\n# handle the button press\ndef buttonPressed(pin):\n    global lastTime, led1, led2\n\n    # get the time the button was pressed and compare it with the last time\n    newTime = utime.ticks_ms()\n    if newTime - lastTime &gt; 200:\n        led1.toggle()\n        led2.toggle()\n        lastTime = newTime\n\n# register the interrupt handler for the button\nbutton.irq(trigger=Pin.IRQ_FALLING, handler=buttonPressed)\n\n# Do nothing loop\nwhile True:\n    sleep(10)\n</code></pre>"},{"location":"micropython/solutions/lab3p/","title":"Our Third Lab: Reading a Button Press","text":""},{"location":"micropython/solutions/lab3p/#solution-polling-method","title":"Solution: Polling Method","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/13/2022\n# Alternating blinking leds\nfrom machine import Pin\nfrom time import sleep\n\n# Define the pin for each led\nled1 = Pin(16, Pin.OUT)\nled2 = Pin(17, Pin.OUT)\n\n# define the pin for the button\nbutton = Pin(15, Pin.IN, Pin.PULL_DOWN)\n\n# make sure one is off and one is on\nled1.low()\nled2.high()\n\n# Toggle when the button is pressed\nwhile True:\n\n    # Was the button pressed?\n    if button.value():\n        led1.toggle()\n        led2.toggle()\n\n        # This is delay to give time to get finger off the button.  \n        sleep(0.5)\n</code></pre>"},{"location":"micropython/solutions/lab4/","title":"Our Fourth Lab: Pulse Width Modulation","text":""},{"location":"micropython/solutions/lab4/#solution-dimming-an-led-to-full-off-then-brightening-an-led-to-full-on","title":"Solution: Dimming an LED to full off, then brightening an LED to full on","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/13/2022\n# Using Pulse Width Modulation to control LED\nfrom machine import Pin, PWM\nfrom time import sleep\n\n# Define the pwm for the led\nled = PWM(Pin(16))\n\n# define the pwm frequency\nled.freq(1000)\n\nwhile True:\n    # Loop from completely off to completely on\n    for dutyCycle in range(65535):\n        led.duty_u16(dutyCycle)\n        sleep(0.0009)\n\n    print('Full bright!')\n\n    # Loop from completely on to completely off\n    for dutyCycle in range(65535, 0, -1):\n        led.duty_u16(dutyCycle)\n        sleep(0.0009)\n\n    print('Full off!')\n</code></pre>"},{"location":"micropython/solutions/lab4/#solution-changing-the-frequency-while-using-pwm","title":"Solution: Changing the Frequency while using PWM","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/13/2022\n# Using Pulse Width Modulation to control LED\n# Add Changing the Frequency that PWM is applied\nfrom machine import Pin, PWM\nfrom time import sleep\n\n# Define the pwm for the led\nled = PWM(Pin(16))\n\n# Set up the list of frequencies\nfrequencyList = [1000, 500, 100, 50, 40, 30, 20, 10]\n\n# run through the list\nfor frequency in frequencyList:\n\n    # define the pwm frequency\n    led.freq(frequency)\n    print('Frequency: ' + str(frequency))\n\n    # Loop from completely off to completely on\n    for dutyCycle in range(65535):\n        led.duty_u16(dutyCycle)\n        sleep(0.0001)\n\n    print('Full bright!')\n\n    # Loop from completely on to completely off\n    for dutyCycle in range(65535, 0, -1):\n        led.duty_u16(dutyCycle)\n        sleep(0.0001)\n\n    print('Full off!')\n</code></pre>"},{"location":"micropython/solutions/lab5/","title":"Our Fifth Lab: Analog to Digital Converter","text":""},{"location":"micropython/solutions/lab5/#solution-using-a-potentiometer-to-control-pwm","title":"Solution: Using a potentiometer to control PWM","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/17/2022\n# Using Pulse Width Modulation to control LED\n# Read from the Potentiometer for the Duty Cycle\nfrom machine import Pin, PWM, ADC\nfrom time import sleep\n\n# Define the pwm for the led\nled = PWM(Pin(16))\n\n# Connect to GP26, which is channel 0\npotentiometer = ADC(Pin(26))\n\n# define the pwm frequency\nled.freq(1000)\n\n# Read the potentiometer, set the duty cycle\noldDutyCycle = 0\ndutyCycle = potentiometer.read_u16()\nwhile True:\n    if oldDutyCycle != dutyCycle:\n        led.duty_u16(dutyCycle)\n        oldDutyCycle = dutyCycle\n    dutyCycle = potentiometer.read_u16()\n    sleep(0.05)\n</code></pre>"},{"location":"micropython/solutions/lab6/","title":"Our Sixth Lab: Photo-Resistor","text":""},{"location":"micropython/solutions/lab6/#solution-using-a-photo-resistor-to-turn-on-and-off-an-led","title":"Solution: Using a Photo-Resistor to Turn On and Off an LED","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/22/2022\n# Night Light LED\n\nfrom machine import Pin, ADC\nfrom time import sleep\n\n# Define the pin for the A/D Converter\nphoto = machine.ADC(26)\n\n# Define the pin for the led\nled = Pin(16, Pin.OUT)\n\nwhile True:\n    if photo.read_u16() &gt; 30000:\n        led.on()\n    else:\n        led.off()\n    sleep(.5)\n</code></pre>"},{"location":"micropython/solutions/lab7/","title":"Our Seventh Lab: NeoPixel Display","text":""},{"location":"micropython/solutions/lab7/#solution-using-a-neopixel-display-to-turn-one-pixel-at-a-time","title":"Solution: Using a NeoPixel Display to Turn One Pixel at a Time","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 03/08/2022\n# Playing with a neopixel bar\n\nimport time\nfrom neopixel import NeoPixel\nfrom machine import Pin\n\n# Number of pixels in the NeoPixel Strip\nNUMBER_PIXELS = 8\n\n# Driver pin\nLED_PIN = 0\n\n# Set the delay\nDELAY = .1\n\n#Define the pin as output\npin = Pin(LED_PIN, Pin.OUT)\n\n# Define the NeoPixel Strip\nstrip = NeoPixel(pin, NUMBER_PIXELS)\n\n# set the colors from https://www.rapidtables.com/web/color/RGB_Color.html\nwhite = (255, 255, 255)\nred = (255, 0, 0)\norange = (255, 165, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (148, 0,211)\nblack = (0, 0, 0)\ngrey = (64, 64, 64)\ncolors = (black, grey, white, red, orange, yellow, green, blue, indigo, violet, black, black)\n\nwhile True:\n    for color in colors:\n        for i in range(NUMBER_PIXELS):\n            strip[i] = color\n            strip.write()\n            time.sleep(DELAY)\n</code></pre>"},{"location":"micropython/solutions/lab7/#solution-using-a-neopixel-display-to-turn-all-the-pixels-at-once","title":"Solution: Using a NeoPixel Display to Turn All the Pixels at Once","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 03/11/2022\n# Playing with a neopixel bar\n\nimport time\nfrom neopixel import NeoPixel\nfrom machine import Pin\n\nNUMBER_PIXELS = 8\nLED_PIN = 0\n\n#Define the pin as output\npin = Pin(LED_PIN, Pin.OUT)\n\n# Define the NeoPixel Strip\nstrip = NeoPixel(pin, NUMBER_PIXELS)\n\ndelay = 1\n\n# set the colors from https://www.rapidtables.com/web/color/RGB_Color.html\nwhite = (255, 255, 255)\nred = (255, 0, 0)\norange = (255, 165, 0)\nyellow = (255, 255, 0)\ngreen = (0, 255, 0)\nblue = (0, 0, 255)\nindigo = (75, 0, 130)\nviolet = (148, 0,211)\nblack = (0, 0, 0)\ncolors = (white, red, orange, yellow, green, blue, indigo, violet, black)\n\nwhile True:\n    for color in colors:\n        strip.fill(color)\n        strip.write()\n        time.sleep(delay)\n</code></pre>"},{"location":"micropython/solutions/lab8/","title":"Our Eigth Lab: Using an SSD1306 Digital Display","text":""},{"location":"micropython/solutions/lab8/#solution-moving-your-name-around-the-display","title":"Solution: Moving Your Name Around the Display","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/29/2022\n# Writing text to a I2C SSD1306 display\nfrom machine import Pin, I2C\nfrom ssd1306 import SSD1306_I2C\nimport time\n\n# Instantiate the I2C &amp; SSD1306 classes\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)\ndisplay = SSD1306_I2C(128, 64, i2c)\n\n# Setup the initial position &amp; direction\nxPos = 0\nyPos = 0\nxDir = 1\nyDir = 1\n\n# Guess at the edge cases\nxEdge = 57\nyEdge = 56\n\n# Loop forever\nwhile True:\n\n   # Clear the old framebuffer, write the new text, then push it to the display\n   display.fill(0)\n   display.text(\"Hello Jet\", xPos, yPos)\n   display.show()\n\n   # Update the x position, then check for edge cases\n   xPos += xDir\n   if xPos &lt; 0:\n       xPos = 0\n       xDir = 1\n   elif xPos &gt; xEdge:\n       xPos = xEdge\n       xDir = -1\n\n   # Update the y position, then check for edge cases\n   yPos += yDir\n   if yPos &lt; 0:\n       yPos = 0\n       yDir = 1\n   elif yPos &gt; yEdge:\n       yPos = yEdge\n       yDir = -1\n\n   # delay\n   time.sleep(.25)\n</code></pre>"},{"location":"micropython/solutions/lab9/","title":"Our Ninth Lab: Using a Joystick to Draw Lines on an SSD1306 Digital Display","text":""},{"location":"micropython/solutions/lab9/#solution-drawing-lines-on-the-display","title":"Solution: Drawing Lines on the Display","text":"<pre><code># Author: J.E. Tannenbaum\n# Initial Release: 01/29/2022\n# Drawing lines on a I2C SSD1306 display\nfrom machine import Pin, I2C, ADC\nfrom ssd1306 import SSD1306_I2C\nimport time\n\n# Takes an input number value and a range between low-and-high and returns it scaled to the new range\ndef scaled(value, istart, istop, ostart, ostop):\n  return int(ostart + (ostop - ostart) * ((int(value) - istart) / (istop - istart)))\n\n# Instantiate the I2C &amp; SSD1306 classes\ni2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=400000)\ndisplay = SSD1306_I2C(128, 64, i2c)\n\n# Turn all pixels off\ndisplay.fill(0)\ndisplay.show()\n\n# Provide info to user\ndisplay.text('Line Drawing', 0, 0, 1)\ndisplay.text('Hit the reset', 0, 20, 1)\ndisplay.text('button to clear', 0, 30, 1)\ndisplay.text('the screen', 0, 40, 1)\ndisplay.show()\n\n# Define the pin for the reset button\nresetButton = Pin(16, Pin.IN, Pin.PULL_UP)\n\n# Wait unti the user hits the button to clear the screen and start drawing\nwhile resetButton.value():\n    time.sleep(.25)\n\n# Turn all pixels off\ndisplay.fill(0)\ndisplay.show()\n\n# Define the Horizontal and Vertical inputs from the Rheostats\nvert = ADC(26)\nhoriz = ADC(27)\n\n# Calculate where to start the line\nx = newX = scaled(vert.read_u16(), 0, 65535, 0, 127)\ny = newY = scaled(horiz.read_u16(), 0, 65535, 0, 63)\n\n# Loop forever\n# Draw the line, look for a reset to clear the screen, and get the new end points for the line\nwhile True:\n    display.line(x, y, newX, newY, 1)\n    x = newX\n    y = newY\n    if resetButton.value() != 1:\n        display.fill(0)\n    display.show()\n    time.sleep(.2)\n    newX = 127 - scaled(vert.read_u16(), 0, 65535, 0, 127)\n    newY = scaled(horiz.read_u16(), 0, 65535, 0, 63)\n</code></pre>"},{"location":"python/conditionals/","title":"Conditionals","text":""},{"location":"python/conditionals/#test-equvalence","title":"Test Equvalence","text":"Condition Test Example Equals a == b 2 + 3 == 5 Not Equals a != b 2 + 2 ! = 5 Less Than a &lt; b 2 &lt; 5 Less Than or Equal a &lt;= b 2 + 2 &lt;= 5 Greater Than a &gt; b 5 &gt; 2 Greater Than or Equal a &gt;= b 5 &gt; 2 + 2 Contains a in b 'a' in 'awesome'"},{"location":"python/conditionals/#logical-conditionals","title":"Logical Conditionals","text":"Condition Expression Explanation Example And a and b Both must be true a == b and c == d Or a or b Either must be true a == b or c == d Not a not in b a is not contained in b 'a' not in 'Antique'"},{"location":"python/conditionals/#when-are-conditionals-used","title":"When are Conditionals Used?","text":"<ul> <li> <p>In an if statement: <pre><code>if i &gt; j:\n   print(str(i) + ' is greater than ' + str(j))\nelif i == j:\n   print(str(i) + ' is equal to ' + str(j))\nelse:\n   print(str(i) + ' is less than ' + str(j))\n</code></pre></p> </li> <li> <p>In a while loop: <pre><code>i = 0\nwhile (i &lt; 10):\n   print(i)\n   i += 1\n</code></pre></p> </li> </ul> <p>Challenge</p> <p>Can you create a square where two parallel sides are blue and the other two parallel sides are red?</p> <p></p>"},{"location":"python/eight/","title":"Eight Queens","text":""},{"location":"python/eight/#a-harder-problem","title":"A harder problem","text":"<p>Try solving the Eight Queens Problem: Place eight queens on a chessboard such that they cannot attack each other.</p> <p>Here is a possible answer to the problem:</p> <p></p> <p>Image from: https://www.researchgate.net/figure/a-A-solution-to-the-non-attacking-8-queens-problem-b-An-optimal-solution-to-the_fig1_278681097</p> <p>Don't give up too quickly!</p> <p>If you need help, here is a solution: https://trinket.io/library/trinkets/cedd39c32c</p>"},{"location":"python/fourSquares/","title":"Drawing Four Squares","text":"![](./img/fourSquares.jpg) <p>Challenge</p> <p>Using what you have learned, can you draw four squares in different colors, then hide the turtle when the drawing is complete?</p> <p>Still need help? Four Squares: https://trinket.io/python/a7e1bf623c</p>"},{"location":"python/fourSquares/#some-hints","title":"Some hints","text":"<ol> <li>Import the turtle library</li> <li>Set the variables for distance and angle<ul> <li>distance = 40</li> <li>angle = 90</li> </ul> </li> <li>Set the color of the turtle<ul> <li>jet.color(\"green\")</li> </ul> </li> <li>Start the fill area<ul> <li>jet.begin_fill()</li> </ul> </li> <li>Draw a square as before, but don't do the last right turn</li> <li>End the fill area<ul> <li>jet.end_fill()</li> </ul> </li> <li>Repeat steps 3 through 6 until all four squares are drawn</li> <li>Hide the Turtle<ul> <li>jet.hideturtle()</li> </ul> </li> </ol>"},{"location":"python/functions/","title":"Functions","text":""},{"location":"python/functions/#what-is-a-function","title":"What is a Function?","text":"<ul> <li>A function is a way to organize code into reusable sections. </li> <li>It is a group of related statements that perform a specific task.  </li> <li>You can pass data, known as parameters, into a function. </li> <li>A function can return data as a result.</li> </ul>"},{"location":"python/functions/#defining-a-function","title":"Defining a Function","text":"<pre><code>def drawSquare():\n    for i in range(4):\n        jet.forward(40)\n        jet.right(90)\n</code></pre>"},{"location":"python/functions/#passing-variables-into-a-function","title":"Passing Variables into a Function","text":"<pre><code>def drawPolygon(sides, distance, angle):\n    for i in range(sides):\n        jet.forward(distance)\n        jet.right(angle)\n</code></pre>"},{"location":"python/functions/#returning-a-result-from-a-function","title":"Returning a Result From a Function","text":"<pre><code>def sumNumbers(numbers):\n    sum = 0\n    for number in numbers:\n        sum += number\n    return sum\n</code></pre>"},{"location":"python/functions/#calling-a-function","title":"Calling a Function","text":"<pre><code>def sumNumbers(numbers):\n    sum = 0\n    for number in numbers:\n        sum += number\n    return sum\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint('The sum of the numbers from 1 to 10 is: ' + str(sumNumbers(numbers)))\n</code></pre> <p>Challenge</p> <p>Can you create a function that draws a polygon in a color?  Once you have the function, try calling it.</p> <p>Using a function: https://trinket.io/python/550d2a8530</p>"},{"location":"python/introduction/","title":"Introduction - Python Journey Map","text":"![Journey Map](./img/journeyMap.jpg)  Credit: Dan McCreary and CoderDojoTC <p>The map above is a visual guide to our Introduction to Python course. Students start their journey in the upper left corner at the green start circle. They then journey through each of the lessons until they reach the finish line. </p>"},{"location":"python/lists/","title":"Lists","text":""},{"location":"python/lists/#a-simple-list","title":"A Simple List","text":"<p>Besides numbers and text, variables can contain a collection of items called a list</p> <ul> <li>For example<ul> <li>a collection (list) of colors: colors = ['green', 'blue', 'red', 'yellow']</li> </ul> </li> <li>Once we create a list, we can use it in a for loop as follows:</li> </ul> <pre><code>colors = ['green', 'blue', 'red', 'yellow']\nfor color in colors:\n    jet.color(color)\n\n    # Draw a square\n</code></pre> <ul> <li>The full code can be found here: https://trinket.io/python/94de1feac8</li> </ul>"},{"location":"python/lists/#what-else-can-we-do-with-a-list","title":"What Else Can We Do With a List?","text":"<p>Let's start with a list: colors = ['green', 'blue', 'red', 'yellow']</p> Operation Result colors.append('green') colors = ['green',\u00a0'blue',\u00a0'red',\u00a0'yellow\u201c, 'green'] colors.insert(2, 'green') colors = ['green',\u00a0'blue', 'green',\u00a0'red',\u00a0'yellow\u201c, 'green'] colors.remove('green') colors = ['blue', 'green',\u00a0'red',\u00a0'yellow\u201c, 'green'] color = colors.pop(2) color = 'red', colors = ['blue', 'green',\u00a0'yellow', 'green'] color = colors.pop() color = 'green',\u00a0colors = ['blue', 'green',\u00a0'yellow'] colors.sort() colors = ['blue', 'green',\u00a0'yellow'] colors.reverse() colors = ['yellow', 'green',\u00a0'blue'] colors.clear() colors = []"},{"location":"python/lists/#taking-it-a-step-further","title":"Taking It a Step Further","text":"<ul> <li>Find the number of elements in a list:</li> </ul> <pre><code>colors = ['green', 'blue', 'red', 'yellow']\nnumber = len(colors)\nprint(number)\n</code></pre> <p>Challenge</p> <ol> <li>Get a random number of colors from the user<ol> <li>hint: color = input('Enter a color: ')</li> </ol> </li> <li>Store the color in a list of colors</li> <li>Draw the polygons, one in each color, in a similar manner to the four squares.<ol> <li>Let the number of sides of each polygon be equal to the number of colors that the user entered<ol> <li>hint: # of sides = len(colors)</li> </ol> </li> <li>Calculate the angle needed to draw a polygon<ol> <li>hint: angle = 360 / # of sides</li> </ol> </li> <li>Loop through all of the colors in the list you created<ol> <li>hint:  <pre><code>for color in colors:\n    # set the color\n    # begin fill\n    # draw polygon\n    # end fill\n# hide the turtle when done.\n</code></pre> </li> </ol> </li> </ol> </li> </ol> <p>What happens if the user only enters two colors?  Can you add a check?</p> <p>Need some help?  Take a look here: https://trinket.io/python/06ab63c75f</p>"},{"location":"python/loops/","title":"Exploring Loops","text":""},{"location":"python/loops/#using-a-loop","title":"Using a Loop","text":"<p>A loop is a way to repeat the same action.</p> <p>Instead of writing:</p> <pre><code># Draw a square:\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\n</code></pre> <p>We can use a loop: <pre><code># Draw a square:\nfor i in range(4):\n    jet.forward(distance)\n    jet.right(angle)\n</code></pre></p> <p>Let's examine the pieces of the for statement:</p> <ol> <li>Starts with the reserved word for</li> <li>Uses a variable that iterates</li> <li>Next is the reserved word in </li> <li>Finally, there is the data that is iterated over.  In this example, we have a set (or range) of numbers. Note: a range is defined (by default) as starting at zero, so range(4) means that we are counting 0, 1, 2, 3. </li> </ol> <p>See a loop in action: https://trinket.io/python/11386c7fa2</p>"},{"location":"python/loops/#more-on-loops","title":"More on Loops","text":"<ul> <li>We can change the starting value of a range, for example: range(2, 6)<ul> <li>What numbers are in this sequence?</li> </ul> </li> <li>We can change the way a loop counts, for example: range(1, 100, 2)<ul> <li>What numbers are in this sequence?</li> </ul> </li> <li>We can nest loops: <pre><code>for x in range(2, 6):\n    for y in range(1, 100, 2):\n        z = x * y\n</code></pre></li> <li>Remember that Python variables can be words as well as numbers, so what happens if we do this? <pre><code>animal = 'squirrel'\nfor x in animal:\n    print(x)\n</code></pre></li> </ul> <p>Experiments</p> <ol> <li>Can you make the turtle draw a larger square?  Hint: change the distance to be 80.  How big can you make the square before the turtle goes off the screen?</li> <li>A polygon's internal angle can be calculated as: angle = 360 / Number of sides.  A square is a type of polygon.  It has four sides, so the internal angle = 360 / 4 = 90 degrees!</li> <li>Can you make a hexagon?  This is a figure with six sides.  Hint: Use the equation above to calculate the internal angle.</li> <li>Can you make an octagon?  An Octagon has eight sides.</li> <li>Can you make a stop sign?  You will need to use a jet.color('red'). a jet.beginfill() and a jet.endfill().  You can add the text of the word \"stop\" by using jet.moveto(x,y) and jet.write('STOP', font=(\"Arial\", 30, \"normal\")).  You can also use the jet.hideturtle() so that the outline of the turtle is not displayed at the end.</li> </ol> <p>Drawing the Stop Sign: https://trinket.io/python/eb27ed7fef</p>"},{"location":"python/recursion/","title":"Recursion","text":""},{"location":"python/recursion/#what-is-recursion","title":"What is Recursion?","text":"<p>Recursion means \"defining a problem in terms of itself\". This can be a very powerful tool in writing algorithms. Recursion comes directly from Mathematics, where there are many examples of expressions written in terms of themselves.</p>"},{"location":"python/recursion/#a-simple-example-walk-home","title":"A Simple Example - Walk Home","text":"<pre><code>def walkHome(stepsFromHome):\n    if stepsFromHome == 0:\n        print('You are home')\n    else:\n        print('Steps from home:' + str(stepsFromHome))\n        walkHome(stepsFromHome - 1)\n\nwalkHome(10)\n</code></pre> <p>Here the solution to finding your way home is two steps (three steps). First, we don't go home if we are already home. Secondly, we do a very simple action that makes our situation simpler to solve. Finally, we redo the entire algorithm.</p> <p>Challenge</p> <ol> <li>Summing a list of numbers:<ul> <li>What is a recursive solution to summing up a list of numbers?<ul> <li>Note that the sum of [1 2 3 4 5 6 7 8 9] is equal to 1 + sum of [2 3 4 5 6 7 8 9]</li> </ul> </li> </ul> </li> <li>Sum counting numbers:<ul> <li>What are counting numbers?<ul> <li>Positive inters from 1 to infinity (and beyond)</li> </ul> </li> <li>If we count backwards, the solution becomes:<ul> <li>sum(1) = 1</li> <li>sum(n) = n + sum(n - 1)</li> </ul> </li> <li>What is sum(20)?</li> </ul> </li> <li>Factorial:<ul> <li>What is the definition of a factorial?<ul> <li>factorial(x) = x * factorial(x - 1)</li> <li>Note: we only use counting numbers, so we will stop at factorial(1)<ul> <li>What is factorial(10)?</li> </ul> </li> </ul> </li> </ul> </li> <li>Fibonacci Sequence:<ul> <li>What is a Fibonacci Sequence?<ul> <li>The sequence is defined as follows:<ul> <li>1, 1, 2, 3, 5, 8, ...</li> <li>fib(x) = fib(x - 1) + fib(x - 2)</li> </ul> </li> <li>Using this equation, we can determine the nth number in the Fibonacci sequence</li> <li>What is the next number in the sequence where fib(0) and fib(1) = 1, fib(2) = 2, etc.?</li> </ul> </li> </ul> </li> </ol>"},{"location":"python/recursion/#solutions","title":"Solutions","text":"<ol> <li> <p>Summing a list of numbers: https://trinket.io/python3/3fc6942d2f</p> </li> <li> <p>Sum the counting numbers up to 20: https://trinket.io/python/2e8cf2b456</p> </li> <li> <p>Factorial: https://trinket.io/python3/ab3e92b2d1</p> </li> <li> <p>Fibonacci: https://trinket.io/python3/dce6382d1f </p> </li> </ol>"},{"location":"python/scope/","title":"Variable Scope","text":""},{"location":"python/scope/#what-is-scope","title":"What is Scope?","text":"<p>A variable is only available from inside the region it is created. This is called scope.  There are two types of scope:</p> <ul> <li>Local Scope: A variable created inside a function belongs to the local scope of that function, and can only be used inside that function.</li> <li>Global Scope: A variable created in the main body of the Python code is a global variable and belongs to the global scope.</li> </ul>"},{"location":"python/scope/#local-scope","title":"Local Scope","text":"<p>A variable that is created inside a function is only available inside that function:</p> <pre><code>def localVariable():\n    myLocalVariable = 12345\n    print(myLocalVariable)\n\nlocalVariable()\n</code></pre> <p>As explained above, the local variable is not available outside of the function.  However, it is available to any nested function:</p> <pre><code>def localVariable():\n    myLocalVariable = 12345\n\n    def printLocalVariable()\n        print(myLocalVariable)\n\n    printLocalVariable()\n\nlocalVariable()\n</code></pre>"},{"location":"python/scope/#global-scope","title":"Global Scope","text":"<p>A variable created outside of a function has global scope and can be used inside or outside of a function</p> <pre><code>distance = 40\n\ndef drawSquare():\n    for i in range(4):\n        jet.forward(distance)\n        jet.right(90)\n\nprint('Draw a square with each side = ' + str(distance))\ndrawSquare()\n</code></pre>"},{"location":"python/scope/#reusing-a-variable-inside-of-a-function","title":"Reusing a variable inside of a function","text":"<pre><code>sum = 0\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndef sumNumbers(numbers):\n    sum = 0\n    for number in numbers:\n        sum += number\n    print(sum) # This will print 55\n\nsumNumbers(numbers)\nprint(sum) # This will print 0\n</code></pre>"},{"location":"python/scope/#global-keyword","title":"Global Keyword","text":"<p>If you need to create a global variable, but are stuck in the local scope, you can use the global keyword.</p> <pre><code>sum = 0\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ndef sumNumbers(numbers):\n    global sum\n\n    for number in numbers:\n        sum += number\n    print(sum) # This will print 55\n\nsumNumbers(numbers)\nprint(sum) # This will also print 55\n</code></pre>"},{"location":"python/simpleSquare/","title":"Drawing a Square","text":"<p>The following code is an example of drawing a square using turtle graphics.  In this example the turtle moves forward 40 units and then turns right.  The angle for the right turn is 90 degrees.  It repeats these two functions four times to make a square.</p>"},{"location":"python/simpleSquare/#sample-code","title":"Sample Code","text":"<pre><code>import turtle           # Load the library\njet = turtle.Turtle()   # Create the turtle object and name it\njet.shape(\"turtle\")     # Set the shape\n\n# Draw a square:\njet.forward(40)\njet.right(90)\njet.forward(40)\njet.right(90)\njet.forward(40)\njet.right(90)\njet.forward(40)\njet.right(90)\n</code></pre>"},{"location":"python/simpleSquare/#drawing","title":"Drawing","text":""},{"location":"python/simpleSquare/#try-it-out","title":"Try it out","text":"<p>Here is a link to the Trinket web site with this program running: https://trinket.io/python/21d5995dac You can click on this link and then press the Run button.  You should see the python code on the left side and the drawing on the right side of your screen.</p>"},{"location":"python/simpleSquare/#explanation","title":"Explanation","text":"<p>The first three lines will be the same for all our programs.  They import the turtle library into our program, create a new turtle object and then assign the turtle a shape icon.  Although almost all the turtle libraries work this way, there are some minor differences you will see in future examples.</p>"},{"location":"python/simpleSquare/#reorienting-your-turtle","title":"Reorienting your turtle","text":"<p>Note that at the start, the turtle is facing to the right.  After the last instruction, it is also facing to the right.  This is a common best practice so that the turtle gets reoriented after some drawing function.  If you remove the last right(90) function and run the program again you will see the turtle ends up facing upward.  But if you rerun the program you will still get the same square because the orientation of the turtle is not stored between runs.</p> <p>Experiments</p> <p>Can you change the distance and angle the turtle moves?  What happens when you change the numbers for the forward and right functions?  Can you go left as well as right?</p> <p>Can you add more motion commands using the copy and paste?</p>"},{"location":"python/towers/","title":"Towers of Hanoi","text":""},{"location":"python/towers/#a-recursive-problem","title":"A recursive problem","text":"<p>The Towers of Hanoi is a classic problem to solve with recursion.  There are three towers.  The first tower has a set of rings, starting at the bottom with the largest ring, and moving up to a smaller ring at ech new level, until we get to the top.  The object is to move the rings from the left most tower, where the rings start, to the right most stack, always making sure that a smaller ring is above a larger ring.</p>"},{"location":"python/towers/#example","title":"Example","text":"<p>Here is an example, using a tower with three rings:</p> <p> Image from: https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/</p>"},{"location":"python/towers/#the-steps","title":"The Steps","text":"<ol> <li>Disk 1 moved from A to C </li> <li>Disk 2 moved from A to B </li> <li>Disk 1 moved from C to B </li> <li>Disk 3 moved from A to C </li> <li>Disk 1 moved from B to A </li> <li>Disk 2 moved from B to C </li> <li>Disk 1 moved from A to C </li> </ol> <p>Challenge</p> <p>Can you write a recursive program to solve the towers of hanoi?</p> <p>To solve the problem, you will need to do the following:</p> <ol> <li> <p>Define a function that takes in the number of discs and the three poles (stacks) as arguments. This function will be used to move the discs from one pole to another.</p> </li> <li> <p>Use a recursive approach to move the discs from the starting pole to the final pole, using the auxiliary pole as a temporary storage.</p> </li> <li> <p>To move a disc, you will need to first move all the discs that are on top of it to the auxiliary pole, using the same function.</p> </li> <li> <p>Once all the discs on top of the current disc have been moved, you can move the disc to the final pole.</p> </li> <li> <p>Repeat this process until all the discs have been moved from the starting pole to the final pole.</p> </li> </ol> <p>A solution: https://trinket.io/python/d425c2e31e</p>"},{"location":"python/trinket/","title":"Getting Started With Trinket","text":"<p>These labs assume that you have internet access and a modern web browser such as Chrome.</p> <p>We'll use the Trinket web site because it a student-safe place that has many of the basic turtle drawing libraries implemented in and easy-to-use web environment.  It is appropriate for students just getting started with python programming.  The free version meets all the needs of our beginning python class.</p>"},{"location":"python/trinket/#what-can-you-do-on-trinket","title":"What can you do on Trinket?","text":"<ol> <li>You can save programs</li> <li>You can share programs</li> <li>You can (re)name programs</li> <li>You can create folders of programs</li> <li>You can run/debug your program</li> <li>You can make the program fill the screen (fullscreen)</li> <li>Download your Python code</li> </ol>"},{"location":"python/trinket/#using-trinket","title":"Using Trinket","text":"<ul> <li> <p>Go to the Trinket web site</p> <ul> <li>Sign up by clicking on the Sign Up area in the right navigation area </li> <li>Create your account by entering the following:<ul> <li>Your name</li> <li>A username</li> <li>Your email (use your school email)</li> <li>A password (Don't use your school password!) </li> </ul> </li> <li>Create a new python trinket<ul> <li>Click on the Blue \"New Trinket\" button</li> <li>Select \"Python\"</li> </ul> </li> </ul> <p></p> </li> </ul>"},{"location":"python/tryExcept/","title":"Exception Handling","text":""},{"location":"python/tryExcept/#four-parts-of-exception-handling","title":"Four Parts of Exception Handling","text":"<ul> <li>try: Lets you test a block of code for errors</li> <li>except: Lets you handle the error</li> <li>else: lets you execute the code when there isn't an error</li> <li>finally: always executes the code, regardless of any error</li> </ul>"},{"location":"python/tryExcept/#handling-the-initial-error","title":"Handling the Initial Error","text":"<ul> <li> <p>How can you handle an error when:</p> <ul> <li>A user enters bad input?</li> <li>There is an error in a calculation?</li> </ul> </li> <li> <p>Handle the error gracefully with exception handling!</p> </li> </ul> <p><pre><code>randomList = ['a', 0, 2]\nfor entry in randomList:\n    try:\n        r = 1/int(entry)\n        print('The reciprocal of ', entry, ' is ', r)\n    except:\n        print('Oops! an exception occurred.')\n        print('No reciprocal for: ', entry)\n</code></pre> Since the error occurs inside the try block, the except block executes and the error message is printed.  If the code was not inside the try block, the program would crash.</p> <p>https://trinket.io/python/4742df2d3a</p>"},{"location":"python/tryExcept/#using-else-when-an-error-didnt-happen","title":"Using else When an Error Didn't Happen","text":"<p>We can use an else block to execute a block of code when there are no errors:</p> <pre><code>randomList = ['a', 0, 2]\nfor entry in randomList:\n    try:\n        r = 1/int(entry)\n        print('The reciprocal of ', entry, ' is ', r)\n    except:\n        print('Oops! an exception occurred.')\n        print('No reciprocal for: ', entry)\n    else:\n        print('Success, we found the reciprical!')\n</code></pre>"},{"location":"python/tryExcept/#finally-using-finally-to-clean-up","title":"Finally, Using finally to clean up","text":"<p>The finally block will always execute, no matter if an error occurs or the code executes without an error</p> <p><pre><code>randomList = ['a', 0, 2]\nwhile randomList != []:\n  entry = randomList[0]\n  try:\n    r = 1/int(entry)\n    print('The reciprocal of ', entry, ' is ', r)\n  except:\n    print('Oops! an exception occurred.')\n    print('No reciprocal for: ', entry)\n  else:\n    print('Success, we found the reciprical!')\n  finally:\n    randomList.pop(0)\n</code></pre> https://trinket.io/python3/7520b1fcd1</p>"},{"location":"python/turtle/","title":"The Turtle Graphics Library","text":""},{"location":"python/turtle/#what-is-the-turtle-graphics-library","title":"What is the turtle graphics library?","text":"<p>Turtle graphics have been around for almost 50 years. A turtle is a drawing object that has position, direction, and a pen to draw as it moves around a grid. Turtle graphics are the preferred way to teach many concepts in computer science because they give you fast feedback.</p> <p>We will use the turtle python library. Although there are many different versions of the turtle library, most of the commands are similar. What you learn with the trinket python system will be useful in other systems also.</p>"},{"location":"python/turtle/#why-use-the-turle-graphics-library","title":"Why use the turle graphics library?","text":"<ul> <li>Fast feedback for learning programming concepts</li> <li>The \u201cturtle\u201d can be any shape, color, or size</li> <li>The turtle can be positioned at any coordinate on the screen</li> <li>It can be moved in any direction from its initial starting point</li> </ul>"},{"location":"python/turtle/#adding-a-turtle-to-your-python-code","title":"Adding a turtle to your Python code","text":"<pre><code>import turtle           # Load the library\njet = turtle.Turtle()   # Create the turtle object and name it (use any name)\njet.shape(\"turtle\")     # Set the shape to be a turtle\n</code></pre>"},{"location":"python/turtle/#moving-the-turtle","title":"Moving the turtle","text":"<p>There are five different ways to move a turtle:</p> <ol> <li>jet.forward(40)</li> <li>jet.back(40)</li> <li>jet.left(90)</li> <li>jet.right(90)</li> <li>jet.goto(x, y)</li> </ol> <p>Challenge</p> <p>Create a trinket with your turtle and draw a square.</p>"},{"location":"python/turtleTricks/","title":"What Else Can a Turtle Do?","text":""},{"location":"python/turtleTricks/#drawing","title":"Drawing:","text":"<ul> <li>jet.penup()       # no drawing happens when the pen is up</li> <li>jet.pendown()     # drawing occurs when the turtle moves</li> <li>jet.color(\"red\")  # set the drawing color</li> <li>jet.pensize(5)    # width of the line from 1 to 20</li> <li>jet.begin_fill()  # start filling the drawing region</li> <li>jet.end_fill()    # end the fill region</li> </ul>"},{"location":"python/turtleTricks/#miscellaneous","title":"Miscellaneous:","text":"<ul> <li>jet.clear()       # clears the drawing area</li> <li>jet.hideturtle()  # hides the turtle icon</li> </ul>"},{"location":"python/turtleTricks/#more","title":"More:","text":"<ul> <li>See https://trinket.io/docs/python and select turtle</li> </ul>"},{"location":"python/usingVariables/","title":"Using Variables","text":"<p>In the simple square program we repeated the numbers for the distance and turning angle four times in four different places.  If we wanted to change the size of our box we would have to change the code in four different places.  By using variables we can make our program easier to change.</p> <p>Modifying the previous example program, we will still make the turtle go forward 40 steps and then make a right turn of 90 degrees.  However, we will use variables to make our life easier.  Note the inclusion of a set of comments before the code, identifying the author, when the code was created, and any changes to the code</p>"},{"location":"python/usingVariables/#sample-code","title":"Sample Code","text":"<pre><code># J.E. Tannenbaum\n# Released: 11/10/2021 - Initial release\n# 11/10/2022 - Cleaned up and added comments\n\nimport turtle             # Load the library\njet = turtle.Turtle()     # Create the turtle object and name it\njet.shape(\"turtle\")       # Set the shape\n\n# Set the distance and angle variables\ndistance = 40\nangle = 90\n\n# Draw the square\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\njet.forward(distance)\njet.right(angle)\n</code></pre> <p>Run Square With Variables: https://trinket.io/python/94326b4743</p> <p>Challenge</p> <p>Can you make the turtle draw a larger square? </p> <ul> <li>Hint: Set the distance variable to 100 instead of 40</li> </ul>"},{"location":"python/variables/","title":"Python Variables","text":""},{"location":"python/variables/#variable-names","title":"Variable Names:","text":"<ul> <li>Must start with a letter or an underscore</li> <li>Can only contain alpha-numeric characters and underscores (A-z, 0-9, and _)</li> <li>Case sensitive (Angle is not the same as angle)</li> </ul>"},{"location":"python/variables/#variables-can-hold-a-variety-of-things","title":"Variables Can Hold a Variety of Things","text":"<ul> <li>Text: angle = \"Ninety degrees\"</li> <li>A number with a decimal point: angle = 90.0</li> <li>A number without a decimal point: angle = 90</li> <li>A collection: angle = [\"Ninety\", 90.0, 90]</li> </ul> <p>Challenge</p> <p>Which Variable Names Are Legal?</p> <ul> <li>SayHello</li> <li>_goodbye!</li> <li>2For1</li> <li>another_variable</li> <li>X</li> <li>_42</li> </ul>"},{"location":"python/whyPython/","title":"Why study Python?","text":""},{"location":"python/whyPython/#7-reasons-to-study-python","title":"7 Reasons to study Python","text":""},{"location":"python/whyPython/#1-perfect-for-beginners","title":"1. Perfect for beginners","text":"<ul> <li>Its conciseness, expressiveness, and likeness to English, all contribute to its popularity.</li> </ul>"},{"location":"python/whyPython/#2-community","title":"2. Community","text":"<ul> <li>A large community also means availability of a large number of libraries, modules, and packages to help you with your project.</li> </ul>"},{"location":"python/whyPython/#3-career-opportunities","title":"3. Career Opportunities","text":"<ul> <li>In the professional world, Python and Ruby developers earn the second highest salaries, next to Swift.</li> </ul>"},{"location":"python/whyPython/#4-web-development","title":"4. Web Development","text":"<ul> <li>Several frameworks are available: Django, Pylons, web2py, and Flask. Of these, Django and Flask are quite impressive.</li> </ul>"},{"location":"python/whyPython/#5-artificial-inteligence-and-machine-learning","title":"5. Artificial Inteligence and Machine Learning","text":"<ul> <li>Today, Python is preferred as the language for computer science research, making use of SciPy and NumPy libraries.</li> </ul>"},{"location":"python/whyPython/#6-raspberry-pi","title":"6. Raspberry Pi","text":"<ul> <li>With MicroPython you can make robots, arcade machines, remote-controlled toys, and even cameras. And with Sonic Pi, you can even make music.</li> </ul>"},{"location":"python/whyPython/#7-startups-and-corporations","title":"7. Startups and Corporations","text":"<ul> <li>Giants like Google, Disney, and NASA are always on the lookout for talented Python professionals.</li> </ul>"},{"location":"robotCar/makerPiRP2040Bot/","title":"Building a remote control robot car with the Maker Pi RP2040","text":"<p>This was the robot car that is built using the parts kit as descriped below.</p> <p>The bot brain is the Maker Pi RP2040.  The Maker Pi board makes building a bot simple, since it is a one board solution built around the RP2040 (the same controller used in the Raspberry Pi Pico).  The board comes with a dual channel DC motor driver, four servo motor ports, seven grove ports, a piezo, and two multi color leds. </p> <p>Maker Pi RP2040 Information</p> <p>The parts kit includes:</p> <p></p> Description Part Chassis kit Maker Pi RP2040 HC-05 or AT-09 Bluetooth module Ultrasonic sensor and mount <p>Additional parts (not included in the kit):</p> <ul> <li>Nuts, bolts, and spacers</li> <li>Wire ties to secure wires</li> <li>Four AA batteries</li> <li>USB Micro B Cable</li> <li>Two optional IR Sensors for line following </li> </ul> <p>Additional software required:</p> <ul> <li>An IDE capable of supporting MicroPython, for example: Thonny</li> <li>Software capable of connecting to and writing to the bluetooth module, for example: LightBlue, available in the iOS &amp; Google Play app stores.  An alternative for Android users is BlueSerial.</li> </ul> <p>There are several parts to this project.  Let's break them down by tasks:</p> <ul> <li>Remove the default CircuitPython run-time</li> <li>Install the MicroPython run-time</li> <li>Communicate with the bluetooth module</li> <li>Get data from the ultrasonic sensor</li> <li>Assemble the chassis </li> <li>Putting it all together</li> </ul> <p>Remove the default CircuitPython run-time</p> <p>The Maker Pi RP2040 comes with the CircuitPython run-time. The first step is to remove CycuitPython with the run-time flash_nuke available here</p> <p>Download the flash_nuke.utf file to your local machine.  With the switch in the off position on the board, connect the board to your computer via the USB cable.  Press and hold the BOOT button (button closest to the Grove 1 port), then turn on the power.  This will make the board look like a USB drive. You can then just drag the flash_nuke.utf file onto the drive and the board will be initialized. Make sure to power the board off and back on without pressing the BOOT button.</p> <p>Install the MicroPython run-time</p> <p>Download the MicroPython run-tme, available here</p> <p>Once again, turn off the board, hold down the BOOT button, and turn on the board.  You should see the board show up as a USB drive again.  Drag the new utf file over to the drive, turn the power off, and turn it back on without pressing the BOOT button.  The MicroPython run-time should now be loaded onto your board.</p> <p>Assuming you are using the Thonny IDE, you should be able to configure the application to use the Raspberry Pi Pico MicroPython interface.  When you are done, press the Stop/Reset button and you should see the MicroPython RPEL prompt identifying the version of MicroPython running on your board.</p> <p>Communicate with the bluetooth module</p> <p>The bluetooth modules communicate at 9600 baud by default, although some older modules use 115200 baud.  Communication is done through the built in UART on the board.  The settings (baud rate, name, etc.) can be changed by sending AT commands to the module.  Sending \"AT+HELP\" to the module will return a list of supported commands.</p> <p>The AT commands for getting/setting baud rate are:</p> Send Receive Parameter AT+BAUD? OK+Get:[P1] P1: Baud Rate AT+BAUD[P1] OK+Set:[P1] 0: 9600; 1: 19200; 2: 38400 . 3: 57600; 4: 115200; 5: 4800 . 6: 2400; 7: 1200; 8: 230400 . Default: 0 (9600) <p>The pins are usually labelled on the back of the module.  Your module with either have six or four pins.  Ignoring the outer most pins (assuming your module has six pins), the pins from left to right as you look at the back of the board are VCC (3.3 VDC), Gnd, Tx, &amp; Rx.  Connect the grove connector wires as follows:</p> Wire Color Module Pin Red VCC Black GND Yellow TXD White RXD <p>Connect the other end of the grove wire harness to the grove 3 port.  Using the following code and your bluetooth application of choice, you should be able to send data to the board and have it display in the terminal window.</p> <p>N.B.: If you are using an Apple device to communicate with the bluetooth module, you must use the AT-09 module.  Apple does not support the HC-05 bluetooth version.</p> <p>An additional note: Some of the BlueTooth modules require a pairing code.  You can find the pairing code by sending AT+PAIR through the UART to the module.  The module will then return the pairing code.  Code to write to the UART is not included here, but is available elsewhere on the site.</p> <p>This is the code: <pre><code>from machine import Pin, UART\n\n# Get the data from the UART\ndef readUartBytes(uart):\n    resp = b\"\"\n    while uart.any():\n        resp = b\"\".join([resp, uart.read(1)])\n    return resp.decode()\n\n# Create the UART\nuart0 = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))\n\n# Loop\nwhile True:\n    data = str(readUartBytes(uart0)) \n    if data != \"\":\n        print(data)\n</code></pre> Get data from the ultrasonic sensor</p> <p>The ultrasonic sensor measures distance using sonar, an ultrasonic (well above human hearing) pulse (~40KHz) is transmitted from the unit and distance-to-target is determined by measuring the time required for the echo return.  The pins are labeled on the front of the module - Vcc  (3.3 VDC), Trig, Echo, and Gnd.</p> <p>Connect the grove connector wires as follows:</p> Wire Color Sensor Pin Red Vcc White Trig Yellow Echo Black Gnd <p>Connect the other end of the grove wire harness to the grove 5 port.  Once connected, wave your hand over the sensor and have it display distance in the terminal window.  For our purposes, we'll convert the measurement to inches.</p> <p>The code is below</p> <pre><code>from machine import Pin\nimport utime\nimport time\n\n# Using Grove 5 Connector\nTRIGGER_PIN = 6 # White Wire\nECHO_PIN = 26 # Yellow Wire\n\n# Init HC-SR04P pins\ntrigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(ECHO_PIN, Pin.IN) # get the delay interval back\n\ndef ping():\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 microseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    return distance * .254\n\nwhile True:\n    print(\"Distance:\", ping(), \"inches\")\n    utime.sleep(.25)\n</code></pre> <p>Assemble the chassis</p> <p></p> <p>Place the Maker PI RP2040 board on the rear of the chassis as shown and mark the small holes that are in each corner.  Make sure the back of the board is closer to the back of the chassis, since the motors will end up close to the front board mounts.</p> <p></p> <p>Once the holes are marked, drill the holes, using an 1/8 inch drill bit.  Be careful, as your mounting holes may be close to existing mount holes in the chassis.  Also note that the chassis is thin plastic, so it must be supported as you drill through it.</p> <p></p> <p>After the holes are drilled, remove the paper from the chassis, motor mounts, and sensor mount.  All parts should be clear plastic after the paper is romoved.</p> <p></p> <p>Gather the wheel, motor, mounts, long screws, and nut as shown above.  Slide the motor mounts through the chassis, then insert and secure the motor with the screws.  Note that the wires will seperate from the motor if not handled with care.  The wires should be on the side of the motor that faces out from the chassis.  Once the motor is mounted, feed the wires through the chassis and optionally secure them with a wire tie.</p> <p></p> <p>Add the wheel once the motor is mounted and repeat for the other side.</p> <p></p> <p>The battery holder is mounted on the bottom of the chassis, nestled between the motors.  The wires from the battery holder should feed to the rear of the chassis.</p> <p></p> <p>Assemble the rear wheel by adding the standoffs to the castor wheel as shown in the above left image.  Then attach it to the chassis.  The wires for the battery holder are shown feeding through the hole to the left of the motor wires.  They will need to be fed through the right side (assembler error).</p> <p></p> <p>Feed the screws up through the bottom of the chassis in the holes that were drilled.  Use the plastic spacers to separate the board from the chassis (and clear the wires), then secure the board with the nuts.  The board should be mounted such that the connections to the motor and battery wires face the rear of the chassis.  The wires can now be trimmed and attached to the board.  Carefully note that the black battery wire connects to the negative (-) green terminal and the red battery wire attaches to the positive (+) green terminal.  The motor wires should connect to the black terminals, with the black wires on the outside (terminals labeled GP8 and GP 11) and the red wires on the inside (terminals labeled GP 9 and GP 10).</p> <p></p> <p>Insert the ultrasonic sensor in the mount with the pins up (it will appear as if the sensor is mounted upside down, well it is).  Then attach the mount to the front of the chassis with the short screws.  Disconnect the wires from the sensor (assuming they are still attached from previous testing) and thread the wires from the grove 5 port through the chassis and back to the sensor.  Use a small wire tie to keep the wires secure.</p> <p></p> <p>The bluetooth module will nestle between the wire ties used to tidy up the wires.  Disconnect the wires from the bluetooth module and thread the wires from the grove 3 port through the chassis and reconnect to the module as shown.  This completes the chassis assembly.</p> <p>Putting it all together</p> <p>Now that all the individual parts have been assembled and tested, the final code is below.  Note that the control wiring for the motors may be different for you.  You may have to adjust in order for your robot car to move as desired. Run the code from your IDE to test functionality before saving it to the board.  You should be able to connect to the bluetooth module to send commands as shown below:</p> Command Direction h halt (stop the wheels) f forward fast (both wheels spin clockwise) s forward slow (both wheels spin clockwise) l turn left (right wheel spins clockwise, left wheel spins counter clockwise) r turn right (right wheel spins counter clockwise, left wheel spins clockwise) <ul> <li>Add additional code to make the bot run backwards (fast or slow) on command.</li> </ul> <p>Additionally, you should be able to wave your hand in front of the ultrasonic sensor and see the wheels slow, reverse, and turn.</p> <p>Add batteries, download the code to the board as main.py, and Happy motoring!</p> <pre><code>from machine import Pin, PWM, UART\nimport utime\nimport time\nfrom neopixel import NeoPixel\n\nNUMBER_PIXELS = 2\nLED_PIN = 18\n\n#Define the pin as output\npin = Pin(LED_PIN, Pin.OUT)\n\n# Define the NeoPixel Strip\nstrip = NeoPixel(pin, NUMBER_PIXELS)\n\n# Color RGB values\nred = (255, 0, 0)\nyellow = (255, 150, 0)\ngreen = (0, 255, 0)\nblack = (0, 0, 0)\nstartColors = (red, black, red, black, yellow, black, yellow, black, green, black, green, black)\n\ndef showColor(color):\n    for i in range(NUMBER_PIXELS):\n        strip[i] = color\n    strip.write()\n\n# Using Grove 5 Connector\nTRIGGER_PIN = 6 # White Wire\nECHO_PIN = 26 # Yellow Wire\n\n# Init HC-SR04P pins\ntrigger = Pin(TRIGGER_PIN, Pin.OUT) # send trigger out to sensor\necho = Pin(ECHO_PIN, Pin.IN) # get the delay interval back\n\ndef ping():\n    trigger.low()\n    utime.sleep_us(2) # Wait 2 microseconds low\n    trigger.high()\n    utime.sleep_us(5) # Stay high for 5 microseconds\n    trigger.low()\n    while echo.value() == 0:\n        signaloff = utime.ticks_us()\n    while echo.value() == 1:\n        signalon = utime.ticks_us()\n    timepassed = signalon - signaloff\n    distance = (timepassed * 0.0343) / 2\n    return distance * .254\n\nBUZZER_PIN = 22\nbuzzer = PWM(Pin(BUZZER_PIN))\n\ndef playTone():\n    buzzer.duty_u16(1000)\n    buzzer.freq(150)\n\ndef stopTone():\n    buzzer.duty_u16(0)\n\n#define the UART\nuart0 = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))\n\n# Get the data from the UART\ndef readUartBytes(uart):\n    resp = b\"\"\n    while uart.any():\n        resp = b\"\".join([resp, uart.read(1)])\n    return resp.decode()\n\n# Motor definitions\nFULL_POWER_LEVEL = 65024\nRIGHT_FORWARD_PIN = 11\nRIGHT_REVERSE_PIN = 10\nLEFT_FORWARD_PIN = 9\nLEFT_REVERSE_PIN = 8\n\nright_forward = PWM(Pin(RIGHT_FORWARD_PIN))\nright_forward.freq(1000)\nright_reverse = PWM(Pin(RIGHT_REVERSE_PIN))\nright_reverse.freq(1000)\nleft_forward = PWM(Pin(LEFT_FORWARD_PIN))\nleft_forward.freq(1000)\nleft_reverse = PWM(Pin(LEFT_REVERSE_PIN))\nleft_reverse.freq(1000)\n\ndef forward():\n    right_reverse.duty_u16(0)\n    left_reverse.duty_u16(0)\n    right_forward.duty_u16(FULL_POWER_LEVEL)\n    left_forward.duty_u16(FULL_POWER_LEVEL)\n\ndef forwardSlow():\n    right_reverse.duty_u16(0)\n    left_reverse.duty_u16(0)\n    right_forward.duty_u16(FULL_POWER_LEVEL // 2)\n    left_forward.duty_u16(FULL_POWER_LEVEL // 2)\n\ndef reverse():\n    right_forward.duty_u16(0)\n    left_forward.duty_u16(0)\n    right_reverse.duty_u16(FULL_POWER_LEVEL)\n    left_reverse.duty_u16(FULL_POWER_LEVEL)\n\ndef reverseSlow():\n    right_forward.duty_u16(0)\n    left_forward.duty_u16(0)\n    right_reverse.duty_u16(FULL_POWER_LEVEL // 2)\n    left_reverse.duty_u16(FULL_POWER_LEVEL // 2)\n\ndef left():\n    left_forward.duty_u16(0)\n    right_reverse.duty_u16(0)\n    left_reverse.duty_u16(FULL_POWER_LEVEL // 2)    \n    right_forward.duty_u16(FULL_POWER_LEVEL // 2)\n\ndef right():\n    right_forward.duty_u16(0)\n    left_reverse.duty_u16(0)\n    right_reverse.duty_u16(FULL_POWER_LEVEL // 2)    \n    left_forward.duty_u16(FULL_POWER_LEVEL // 2)\n\ndef stop():\n    right_forward.duty_u16(0)\n    right_reverse.duty_u16(0)\n    left_forward.duty_u16(0)\n    left_reverse.duty_u16(0)\n\ndef reverseAndTurn():\n    utime.sleep(.5)\n    reverseSlow()\n    utime.sleep(1.5)\n    left_reverse.duty_u16(0)\n    left_forward.duty_u16(FULL_POWER_LEVEL // 2)\n    utime.sleep(.75)\n    stop()\n    utime.sleep(.25)\n    stopTone()\n\nstop()    \nauto = False;\nautoPin = Pin(20, Pin.IN)\nleftPin = Pin(7, Pin.IN)\nrightPin = Pin(0, Pin.IN)\nfor i in range(20):\n    if not autoPin.value():\n        auto = True\n        utime.sleep(.25)\n\nfor color in startColors:\n    showColor(color)\n    utime.sleep(.5)\n\nwhile auto:\n    if leftPin.value() and rightPin.value():\n        stop()\n    elif leftPin.value():\n        left()\n    elif rightPin.value():\n        right()\n    else:\n        forwardSlow()\n\nforward()      # Assume the way ahead is clear\ncolor = green\nwhile True:\n    dir = readUartBytes(uart0) # read from the UART\n    if dir == 'h':\n        stop()\n        color = red\n    elif dir == 'f':\n        forward()\n        color = green\n    elif dir == 'l':\n        left()\n        color = green\n    elif dir == 'r':\n        right()\n        color = green\n    distance = ping()  # Check the distance\n    if distance &lt; 5 or dir == 's':   # Obstruction ahead, slow down\n        forwardSlow()\n        color = yellow\n    if distance &lt; 2.5: # Obstruction too close, stop, and play tone\n        stop()\n        color = red\n        playTone()\n    showColor(color)\n    if distance &lt; 2.5:  # If we were too close, back up and turn\n        reverseAndTurn()\n        forward()\n        color = green\n</code></pre> <p>The instructions for using the line sensors are as follows</p> <p>Attach the sensors to the front of the chassis as shown</p> <p></p> <p>Red wire to VCC</p> <p>Black wire to GND</p> <p>White wite to DO</p> <p>The left sensor should be connected to Grove 7 and the right sensor should be connected to Grove 1</p> <p>To start the line following code, start with the power switch in the off position, hold down the GP20 button, turn on the power switch,  wait until the board starts flashing red, then release the button and place the bot on the track.  You may need to adjust the sensitivity  of the sensors such that it picks up the difference between the dark line and the light \"track.\"  I use black electrical tape on white card  stock paper for my track.     </p>"},{"location":"robotics/chassisBuild/","title":"Building a robot car with the Maker Pi RP2040","text":""},{"location":"robotics/chassisBuild/#the-robot-car-chassis-kit-assembly","title":"The Robot Car Chassis Kit Assembly","text":""},{"location":"robotics/chassisBuild/#locating-the-maker-pi-rp2040-board","title":"Locating the Maker Pi RP2040 Board","text":"<p>Place the Maker PI RP2040 board on the rear of the chassis as shown and mark the small holes that are in each corner.  Make sure the back of the board is closer to the back of the chassis, since the motors will end up close to the front board mounts.</p> <p></p> <p>Once the holes are marked, drill the holes, using a 1/8 inch drill bit.  Be careful, as your mounting holes may be close to existing mount holes in the chassis.  Also note that the chassis is thin plastic, so it must be supported as you drill through it.</p> <p></p> <p>After the holes are drilled, remove the paper from the chassis and motor mounts.  All parts should be clear plastic after the paper is removed.</p>"},{"location":"robotics/chassisBuild/#start-with-the-wheel-and-motor-assembly","title":"Start with the wheel and motor assembly","text":"<p>Gather the wheel, motor, mounts, long screws, and nuts as shown above.  Slide the motor mounts through the chassis, then insert and secure the motor with the screws.  Note that the wires will seperate from the motor if not handled with care.  The wires should be on the side of the motor that faces out from the chassis.  Once the motor is mounted, feed the wires through the chassis and optionally secure them with a wire tie.</p> <p></p> <p>Add the wheel once the motor is mounted and repeat for the other side.</p>"},{"location":"robotics/chassisBuild/#add-the-battery-holder","title":"Add the battery holder","text":"<p>The battery holder is mounted on the bottom of the chassis, nestled between the motors.  Use the short screws and nuts to secure the battery holder to the chassis.  The wires from the battery holder should feed to the rear of the chassis.</p>"},{"location":"robotics/chassisBuild/#next-add-the-rear-wheel-assembly","title":"Next, add the rear wheel assembly","text":"<p>Assemble the rear wheel by adding the standoffs to the castor wheel as shown in the above left image.  Then attach it to the chassis.  The wires for the battery holder are shown feeding through the hole to the left of the motor wires.  They will need to be fed through the right side (assembler error).</p>"},{"location":"robotics/chassisBuild/#finally-add-the-maker-pi-rp2040-board","title":"Finally, add the Maker Pi RP2040 board","text":"<p>Feed the screws up through the bottom of the chassis in the holes that were drilled.  Use the stand-offs to separate the board from the chassis (and clear the wires), then secure the board with the nuts.  The board should be mounted such that the connections to the motor and battery wires face the rear of the chassis.  The wires can now be trimmed and attached to the board.  Carefully note that the black battery wire connects to the negative (-) green terminal and the red battery wire attaches to the positive (+) green terminal.  The motor wires should connect to the black terminals, with the black wires on the outside (terminals labeled GP8 and GP 11) and the red wires on the inside (terminals labeled GP 9 and GP 10).</p>"},{"location":"robotics/chassisBuild/#about-the-maker-pi-rp2040","title":"About the Maker Pi RP2040","text":"<p>The robot car's brain is the Maker Pi RP2040.  The Maker Pi board makes building a robot simple, since it is a one board solution built around the RP2040 (the same controller used in the Raspberry Pi Pico).  The board comes with a dual channel DC motor driver to drive the wheels, four servo motor ports, seven grove ports for digital I/O, Indicator LEDs, a piezo, and two Neopixel leds.</p> <p>Maker Pi RP2040 Information</p>"},{"location":"robotics/functionsLoops/","title":"Functions and Loops","text":""},{"location":"robotics/functionsLoops/#what-is-a-function","title":"What is a Function?","text":"<ul> <li>A function is a way to organize code into reusable sections. </li> <li>It is a group of related statements that perform a specific task.  </li> <li>You can pass data, known as parameters, into a function. </li> <li>A function can return data as a result.</li> </ul>"},{"location":"robotics/functionsLoops/#defining-a-function","title":"Defining a Function","text":"<pre><code>def forward():\n    right_reverse.duty_u16(0)\n    left_reverse.duty_u16(0)\n    right_forward.duty_u16(32768)\n    left_forward.duty_u16(32768)\n</code></pre>"},{"location":"robotics/functionsLoops/#passing-variables-into-a-function","title":"Passing Variables into a Function","text":"<pre><code>def forward(speed):\n    right_reverse.duty_u16(0)\n    left_reverse.duty_u16(0)\n    right_forward.duty_u16(speed)\n    left_forward.duty_u16(speed)\n</code></pre>"},{"location":"robotics/functionsLoops/#returning-a-result-from-a-function","title":"Returning a Result From a Function","text":"<pre><code>def distanceToObject():\n    # Some code\n    return distance_cm\n</code></pre>"},{"location":"robotics/functionsLoops/#calling-a-function","title":"Calling a Function","text":"<pre><code>forward(SPEED)\ndistance_cm = distanceToObject()\n</code></pre>"},{"location":"robotics/functionsLoops/#using-a-loop","title":"Using a Loop","text":"<p>A loop is a way to repeat the same action.</p>"},{"location":"robotics/functionsLoops/#we-can-use-a-loop-to-have-our-car-move-in-a-square","title":"We can use a loop to have our car move in a square","text":"<pre><code>for i in range(4):\n    forward(SPEED)\n    sleep(3)\n    right(HALF_SPEED)\n    sleep(1.5)\nstop()\n</code></pre>"},{"location":"robotics/functionsLoops/#lets-examine-the-pieces-of-the-for-statement","title":"Let's examine the pieces of the for statement:","text":"<ol> <li>Starts with the reserved word for</li> <li>Uses a variable that iterates</li> <li>Next is the reserved word in </li> <li>Finally, there is the data that is iterated over.  In this example, we have a set (or range) of numbers. Note: a range is defined (by default) as starting at zero, so range(4) means that we are counting 0, 1, 2, 3. </li> </ol> <p>Challenge</p> <p>Rewrite the main.py code to use functions for forward, reverse, left, right, and stop</p> <p>Use a loop so you don't \"cut and paste\" code</p> <p>After your robot successfully moves in a square, can you make it move in an octogon route?</p>"},{"location":"robotics/lights/","title":"Adding Lights","text":"<p>The Maker Pi RP2040 board has two Neopixel LEDs.  We can use them to tell us what the robot is doing.</p>"},{"location":"robotics/lights/#learn-about-neopixel-leds","title":"Learn About Neopixel LEDs","text":"<ul> <li> <p>Controlling NeoPixel LEDs is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver library that is built into Micropython so that the users don't need to see this code.</p> </li> <li> <p>Neopixel colors are set as a triplet of red, green, and blue intensities (0-255).  For example:</p> <ul> <li>Red (255, 0, 0)</li> <li>Green (0, 255, 0)</li> <li>Blue (0, 0, 255)</li> <li>Yellow (255, 255, 0)</li> <li>White (255, 255, 255)</li> <li>Black (0, 0, 0)</li> </ul> </li> <li> <p>A wide variety of colors are possible.  Take a look at this page for some of the other possibilities: RGB Color Chart</p> </li> </ul>"},{"location":"robotics/lights/#using-neopixel-leds","title":"Using Neopixel LEDs","text":"<pre><code>from machine import Pin\nfrom neopixel import NeoPixel\nfrom time import sleep\n\n# Define the GPIO pin connected to the RGB LEDs\nLED_PIN = 18 \n\n# Initialize the NeoPixel object\nnp = NeoPixel(Pin(LED_PIN), 2)  # '2' indicates a two LEDs\n\nYELLOW = (255, 255, 0)\nBLACK = (0, 0, 0)\n\ncolorList = (YELLOW, BLACK)\n\ndef setColor(color):\n    # Set the color of the RGB LEDs\n    for id in range(2):\n        np[id] = color\n    np.write()\n\nwhile True:\n    for color in colorList:\n        setColor(color)\n        sleep(1)\n</code></pre> <p>The code above adds a list object to make alternating the colors easier to manage.</p> <p>Challenge</p> <p>Rewrite the main.py code to use the Neopixel LEDs to signal the start of your car.  You should use a \"count down\" of colors: Blinking Red, then Blinking Yellow, then Blinking Green before the car starts to move.</p> <p>Once the car is in motion, use the Neopixel LEDs to signal when the car is in forward motion (Green), Turning (blinking left or right LED), Slowing (Yellow), or Stopping (Red)</p>"},{"location":"robotics/lineFollowing/","title":"Line Following","text":""},{"location":"robotics/lineFollowing/#detecting-light-and-dark","title":"Detecting Light and Dark","text":"<p>We are going to use the IR Sensors to detect the line that we want the cars to follow.</p>"},{"location":"robotics/lineFollowing/#key-points-about-how-an-ir-sensor-works","title":"Key Points About How an IR Sensor Works:","text":"<ul> <li>Emitting infrared light: The sensor has a small LED that emits infrared light, which is invisible to the human eye.</li> <li>Reflection and Detection: When this infrared light hits an object, some of it is reflected back towards the sensor's receiver, which is a phototransistor sensitive to infrared radiation.</li> <li>Signal interpretation: The receiver converts the reflected infrared light into an electrical signal that can be interpreted by a microcontroller, indicating the presence of an object.</li> </ul>"},{"location":"robotics/lineFollowing/#mounting-and-connecting-the-sensors","title":"Mounting and Connecting the Sensors","text":"<p>The sensors are mounted to the front of the car using the black screws. Use two grove connector wires (one for each sensor) to connect the sensors to the Maker Pi RP2040 board.  Connect the wires as follows:</p> Wire Color Sensor Pin Red VCC Black GND White DO Yellow AO <p>The left sensor should be connected to Grove 7 and the right sensor should be connected to Grove 1.  Use wire ties as needed to dress the wires.  The sensitivity of the sensor is set using the small variable resistor on the top of the sensor.</p>"},{"location":"robotics/lineFollowing/#how-to-read-the-sensor","title":"How to Read the Sensor","text":"<p>The DO pin of the sensor is a digital output that can be read by the Maker Pi RP2040 board.  The left sensor is connected to GP7 and the right sensor is connected to GP0.  We can detect the value of each of the sensors using the following code:</p> <pre><code>left_sensor = Pin(7, Pin.IN)\nright_sensor = Pin(0, Pin.IN)\n\nleft_IR = left_sensor.value()\nright_IR = right_sensor.value()\n</code></pre> <p>Challenge</p> <p>Using what you just learned, can you modify the main.py code so the car follows a line along a track?</p> <p></p>"},{"location":"robotics/movement/","title":"Getting the Robot Car to Move","text":""},{"location":"robotics/movement/#connect-your-computer-to-the-maker-pi-rp2040","title":"Connect your Computer to the Maker Pi RP2040","text":"<p>Use the USB cable to connect your laptop to the Maker Pi RP2040.  Once connected, move the switch to the the ON position.  You should see the green light turn on.</p> <p></p>"},{"location":"robotics/movement/#loading-the-micropython-interpreter-onto-the-maker-pi-rp2040-using-thonny","title":"Loading the MicroPython interpreter onto the Maker Pi RP2040 using Thonny","text":"<p>Now that your board is connected, you need to download the MicroPython interpreter using the Thonny application.  Start Thonny, then select Install MicroPython... from the bottom right corner of the main window.</p> <p></p> <p>Select the Raspberry Pi Pico / Pico H from the variant pulldown and use the latest version.  Then click Install.</p> <p></p> <p>Close the Install window after the the install is done.  Click on the red STOP icon at the top of the main window once the install window closes.  You should see the latest version of MicroPython in the bottom window.</p>"},{"location":"robotics/movement/#using-digital-io","title":"Using Digital I/O","text":"<p>Our board has digital input and output ports.  They are either on or off.  You can see that by typing the following in the main window, then clicking on the GREEN icon.  You will see one of the wheels turn at full speed and then stop after 5 seconds:</p> <pre><code>from machine import Pin\nfrom time import sleep\nwheel = Pin(11, Pin.OUT)\nwheel.value(1)\nsleep(5)\nwheel.value(0)\n</code></pre>"},{"location":"robotics/movement/#using-pulse-width-modulation-pwm-to-control-the-speed-of-the-motors","title":"Using Pulse Width Modulation (PWM) to Control the Speed of the Motors","text":""},{"location":"robotics/movement/#pwm-how-does-it-work","title":"PWM - How Does It Work?","text":"<ul> <li> <p>PWM is controlled by two factors:</p> <ul> <li>How fast does the power turn on and off (frequency)</li> <li>How long is the power on, relative to the power being off (duty cycle)</li> </ul> <p></p> </li> <li> <p>We can declare that an output pin is a PWM pin as follows:</p> <pre><code>from machine import Pin, PWM\nfrom time import sleep\n\npwmWheel = PWM(Pin(11))\n</code></pre> </li> <li> <p>Now set the frequency and the duty cycle:</p> <pre><code># Apply and remove power 1000 times/second (too fast to see)\npwmWheel.freq(1000)\n\n# Apply voltage 50% of the time (Move at 1/2 speed) for 5 seconds\n# Range is 0 - 65535\npwmWheel.duty_u16(32768)\nsleep(5)\npwmWheel.duty_u16(0)\n</code></pre> </li> </ul>"},{"location":"robotics/movement/#controlling-the-motors","title":"Controlling the Motors","text":"<p>Now that we know some basic MicroPython, let's use it to control both of the motors.  We need some code to allow the Maker Pi RP2040 board to control each motor.  Notice that we need to define a seperate PWM Pin for each wheel, forward and backward:</p> <pre><code>from machine import Pin, PWM\nfrom time import sleep\n\n# Motor definitions\nright_forward = PWM(Pin(11))\nright_forward.freq(1000)\nright_reverse = PWM(Pin(10))\nright_reverse.freq(1000)\nleft_forward = PWM(Pin(9))\nleft_forward.freq(1000)\nleft_reverse = PWM(Pin(8))\nleft_reverse.freq(1000)\n\n# Wait 2 seconds before moving\nsleep(2)\n\n# Move Forward at half speed for 2 seconds\nright_reverse.duty_u16(0)\nleft_reverse.duty_u16(0)\nright_forward.duty_u16(32768)\nleft_forward.duty_u16(32768)\nsleep(2)\n\n# Move Backwards at half speed for 2 seconds\nright_forward.duty_u16(0)\nleft_forward.duty_u16(0)\nright_reverse.duty_u16(32768)\nleft_reverse.duty_u16(32768)\nsleep(2)\n\n# Stop Moving\nright_forward.duty_u16(0)\nright_reverse.duty_u16(0)\nleft_forward.duty_u16(0)\nleft_reverse.duty_u16(0)\n</code></pre>"},{"location":"robotics/movement/#whats-next","title":"What's Next?","text":"<p>We need to install batteries and download code to the Maker PI RP2040 board in order to have the robot move on it's own.  Use Thonny's SAVE icon to save the code to the board by selecting Rasperry Pi Pico and saving the file as main.py.</p> <p></p> <p>Challenge</p> <ol> <li> <p>Can you have the robot autonomously move in a straight line for three feet?</p> </li> <li> <p>Can you have the robot autonomously move in a square and return to it's starting point?</p> <p>Note: The car will turn left or right when the wheels spin in the opposite directions.</p> </li> </ol>"},{"location":"robotics/obstacles/","title":"Avoiding Obstacles with an Ultrasonic Sensor and a Servo","text":"<p>Now that we know how to stop when the car runs head on to an obstacle, what happens if we want to move around an obstacle or run the car on an obstacle course?</p>"},{"location":"robotics/obstacles/#controlling-servo-motors","title":"Controlling Servo Motors","text":"<p>There are 4 dedicated connection points on the Maker Pi RP2040 board for connecting up servo motors. These motors have 3 wires: ground (brown), power (red), and signal (orange).  The board uses GP12, GP13, GP14,and GP15 are the dedicated pins for the servos.  We will use GP13 for our servo connection.  </p>"},{"location":"robotics/obstacles/#installing-the-micropython-servo-library","title":"Installing the Micropython-servo Library","text":"<p>We can use a pre-existing library to control our servo.  We'll use Thony's Manage library tool to do so using the following steps:</p>"},{"location":"robotics/obstacles/#click-on-tools-then-select-manage-libraries-form-the-top-navigation-menu","title":"Click on Tools, then select manage libraries form the top navigation menu","text":""},{"location":"robotics/obstacles/#we-want-to-use-the-micropython-servo-library","title":"We want to use the micropython-servo library","text":""},{"location":"robotics/obstacles/#select-the-library-and-install","title":"Select the library and install","text":""},{"location":"robotics/obstacles/#using-the-library","title":"Using the Library","text":"<pre><code>from time import sleep\nfrom servo import Servo\n\n# According to the servo box, the pulse width range is 500usec to 2500 usec \nservo = Servo(pin_id=13, min_us=500.0,max_us=2500.0)\nfor degrees in range(0,180,5):\n    servo.write(degrees)\n    sleep(1)\n</code></pre>"},{"location":"robotics/obstacles/#whats-next","title":"What's Next?","text":"<p>We need to remove the ultrasonic sensor and mount, and install the mount on the servo.</p>"},{"location":"robotics/obstacles/#mounting-the-sensor-on-the-servo","title":"Mounting the Sensor on the Servo","text":"<ol> <li> <p>Use a wire tie to secure the servo to the chassis.</p> </li> <li> <p>Use the short screw that comes with the servo to mount the \"plus shaped\" plastic to the servo.</p> </li> <li> <p>Finally, mount the sensor assemble to the \"plus shaped\" piece with the longer screws.</p> </li> </ol> <p></p> <p>Challenge</p> <p>Using what you just learned, can you modify the main.py code so the car turns away from an obstacle and continues straight ahead when unobstructed?</p>"},{"location":"robotics/ultrasonicSensor/","title":"Collision Avoidance with an Ultrasonic Sensor","text":"<p>The ultrasonic sensor measures distance using sonar, an ultrasonic (well above human hearing) pulse (~40KHz) is transmitted from the unit and distance-to-target is determined by measuring the time required for the echo return.  </p>"},{"location":"robotics/ultrasonicSensor/#mounting-the-sensor","title":"Mounting the Sensor","text":"<p>Find the ultrasonic sensor, mount, wire ties, grove connector wire, and screws in the box.  The sensor is in a bag labeled SN-HC-SR04P.  Use the silver screws.</p> <p></p> <p>Insert the ultrasonic sensor in the mount with the pins up (it will appear as if the sensor is mounted upside down, well it is).  Then attach the mount to the front of the chassis with the silver screws.  Thread the wires from the grove 5 port through the chassis and back to the sensor.  Use a small wire tie to keep the wires secure.</p> <p>The pins are labeled on the front of the module - Vcc  (3.3 VDC), Trig, Echo, and Gnd.</p> <p>Connect the grove connector wires to the sensor as follows:</p> Wire Color Sensor Pin Red Vcc White Trig Yellow Echo Black Gnd"},{"location":"robotics/ultrasonicSensor/#a-brief-lesson-on-conditionals","title":"A Brief Lesson on Conditionals","text":""},{"location":"robotics/ultrasonicSensor/#test-equvalence","title":"Test Equvalence","text":"Condition Test Example Equals a == b 2 + 3 == 5 Not Equals a != b 2 + 2 ! = 5 Less Than a &lt; b 2 &lt; 5 Less Than or Equal a &lt;= b 2 + 2 &lt;= 5 Greater Than a &gt; b 5 &gt; 2 Greater Than or Equal a &gt;= b 5 &gt;= 2 + 2"},{"location":"robotics/ultrasonicSensor/#logical-conditionals","title":"Logical Conditionals","text":"Condition Expression Explanation Example And a and b Both must be true a == b and c == d Or a or b Either must be true a == b or c == d"},{"location":"robotics/ultrasonicSensor/#when-are-conditionals-used","title":"When are Conditionals Used?","text":"<p>They are used when we want to test conditions in an if statement:</p> <pre><code>if distance_cm &gt; COLLISION_DISTANCE_CM:\n   forward(FULL_SPEED)\nelif distance_cm &lt;= COLLISION_DISTANCE_CM and distance_cm &gt; HALF_COLLISION_DISTANCE_CM:\n   forward(HALF_SPEED)\nelse:\n   stop()\n</code></pre>"},{"location":"robotics/ultrasonicSensor/#we-need-a-library-to-use-the-sensor","title":"We Need a Library to use the Sensor","text":"<p>Use your browser and search for: Roberto S\u00e1nchez hcsr04.  Then select micropython-hcsr04/hcsr0.py at master from the result list.</p> <p>Copy the code from the page by clicking on the Raw icon</p> <p></p> <p>Paste the code into a Thonny window, then save it as hcsr04.py to the Maker Pi RP2040 board (use the Raspberry Pi Pico)</p>"},{"location":"robotics/ultrasonicSensor/#lets-test","title":"Let's Test!","text":"<p>Open a new window in Thonny and type the following:</p> <pre><code>from hcsr04 import HCSR04\nfrom machine import Pin, PWM\nfrom time import sleep\n\n# Search for Roberto S\u00e1nchez hcsr04 to get the library\n\nCHECK_DISTANCE_CM = 25\n\nsensor = HCSR04(trigger_pin=6, echo_pin=26)\nbuzzer = PWM(Pin(22))\nbuzzer.freq(1000)\nbuzzer.duty_u16(0)\n\nwhile True:\n    distance_cm = sensor.distance_cm()\n    if distance_cm &lt; CHECK_DISTANCE_CM:\n        buzzer.duty_u16(3500)\n        sleep(.5)\n    else: \n        buzzer.duty_u16(0)\n</code></pre>"},{"location":"robotics/ultrasonicSensor/#whats-happening","title":"What's Happening?","text":"<p>Start the program.  Use your hand to move close to the sensor.  Do you hear the buzzer alert you that you are close to the sensor?  The code is calling the library you stored on the Maker Pi RP2040 board with the parameters that define the pins used to get a reading.  Next, we'll use the internal buzzer on the board to let us know when something is close to the sensor.  Finally, the code loops forwever, getting the distance measurement and comparing it to the CHECK_DISTANCE_CM.  If your hand is within range, the buzzer makes a sound.</p> <p>Challenge</p> <p>Using what you just learned, can you modify the main.py code so:</p> <ol> <li> <p>Starting at 100cm: forward duty_cycle is 60,000 and the LEDs are Green</p> </li> <li> <p>At 50cm from the barrier: the forward duty_cycle is 30,000 and the LEDs are Yellow</p> </li> <li> <p>At 20cm from the barrier: the car stops before hitting a barrier and the LEDs are Red?</p> </li> </ol> <p>Note: the car should move forward in a straight line, so you may have to modify the forward duty_cycle for each wheel.</p>"},{"location":"robotics/variables/","title":"Using Variables","text":""},{"location":"robotics/variables/#variable-naming-rules","title":"Variable Naming Rules","text":"<ul> <li>Must start with a letter or an underscore</li> <li>Can only contain alpha-numeric characters and underscores (A-z, 0-9, and _)</li> <li> <p>Case sensitive (Delay is not the same as delay)</p> <p>Challenge</p> <p>Which Variable Names Are Legal?</p> <ol> <li>MrRoberts</li> <li>_goodbye!</li> <li>2For1</li> <li>Mr.Tannenbaum</li> <li>X</li> <li>_wait</li> <li>_2</li> </ol> </li> </ul>"},{"location":"robotics/variables/#python-is-both-a-strongly-type-and-dynamically-type-language","title":"Python is both a Strongly Type and Dynamically Type Language","text":"<ul> <li>Strong typing means that the type of a value doesn't change in unexpected ways. A string containing only digits doesn't magically become a number. Every change of type requires an explicit conversion.</li> <li>Dynamic typing means that runtime objects (values) have a type, as opposed to static typing where variables have a type.</li> </ul>"},{"location":"robotics/variables/#what-does-that-mean","title":"What Does That Mean?","text":"<ul> <li>Text (string): wait = \"two\"</li> <li>Number with a decimal point (float): wait = 2.0</li> <li>Number without a decimal point (int): wait = 2</li> <li>A Collection (list): wait = [\"Two\", 2.0, 2]</li> </ul> <p>For example, the duty_u16 method from the PWM library only accepts a positive integer.</p>"},{"location":"robotics/variables/#so","title":"So?","text":"<p>We can use variables to make driving the robot car simpler.  For example, we can create the following variables (use upper case to denote constants):</p> <ul> <li>SPEED = 32768</li> <li>DELAY = 2</li> <li>FREQUENCY = 1000</li> </ul> <p>Now we can have the robot car easily move faster or further without changing the numbers in multiple places.  The simple code we had last time becomes:</p> <pre><code>from machine import Pin, PWM\nfrom time import sleep\n\nDELAY = 2\nSPEED = 32768\nFREQUENCY = 1000\n\n# Motor definitions\nright_forward = PWM(Pin(11))\nright_forward.freq(FREQUENCY)\nright_reverse = PWM(Pin(10))\nright_reverse.freq(FREQUENCY)\nleft_forward = PWM(Pin(9))\nleft_forward.freq(FREQUENCY)\nleft_reverse = PWM(Pin(8))\nleft_reverse.freq(FREQUENCY)\n\n# Wait before moving\nsleep(DELAY)\n\n# Move Forward\nright_reverse.duty_u16(0)\nleft_reverse.duty_u16(0)\nright_forward.duty_u16(SPEED)\nleft_forward.duty_u16(SPEED)\nsleep(DELAY)\n\n# Move Backwards\nright_forward.duty_u16(0)\nleft_forward.duty_u16(0)\nright_reverse.duty_u16(SPEED)\nleft_reverse.duty_u16(SPEED)\nsleep(DELAY)\n\n# Stop Moving\nright_forward.duty_u16(0)\nright_reverse.duty_u16(0)\nleft_forward.duty_u16(0)\nleft_reverse.duty_u16(0)\n</code></pre> <p>If we want to move further or change the speed we can simply change the value of the variables.</p> <p>Challenge</p> <p>Rewrite the main.py code to use variables</p> <p>Move farther (four feet) or make a larger square</p> <p>Move at a slower speed (how slow can you go and still move in a straight line?)</p>"}]}